
extern crate libc;

#[macro_use]
extern crate bitflags;

pub mod vkrust {

use libc::{c_int, c_void};
use std::ptr;

pub type VkDeviceSize = i64;
pub type VkSampleMask = i32;

pub type PFN_vkAllocationFunction = *const c_void;
pub type PFN_vkReallocationFunction = *const c_void;
pub type PFN_vkFreeFunction = *const c_void;
pub type PFN_vkInternalAllocationNotification = *const c_void;
pub type PFN_vkInternalFreeNotification = *const c_void;
pub type PFN_vkDebugReportCallbackEXT = *const c_void;
pub type PFN_vkVoidFunction = *const c_void;

// TODO: how to do unions in rust?
pub struct VkClearColorValue {
	col: f32
}

pub struct VkClearValue {
	col: VkClearColorValue
}
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: usize = 256;
pub const VK_UUID_SIZE: usize = 16;
pub const VK_LUID_SIZE_KHX: usize = 8;
pub const VK_MAX_EXTENSION_NAME_SIZE: usize = 256;
pub const VK_MAX_DESCRIPTION_SIZE: usize = 256;
pub const VK_MAX_MEMORY_TYPES: usize = 32;
pub const VK_MAX_MEMORY_HEAPS: usize = 16;
pub const VK_LOD_CLAMP_NONE: f32 = 1000.0;
pub const VK_REMAINING_MIP_LEVELS: usize = ::std::usize::MAX;
pub const VK_REMAINING_ARRAY_LAYERS: usize = ::std::usize::MAX;
pub const VK_WHOLE_SIZE: u64 = ::std::u64::MAX;
pub const VK_ATTACHMENT_UNUSED: usize = ::std::usize::MAX;
pub const VK_TRUE: usize = 1;
pub const VK_FALSE: usize = 0;
pub const VK_QUEUE_FAMILY_IGNORED: usize = ::std::usize::MAX;
pub const VK_QUEUE_FAMILY_EXTERNAL_KHX: usize = ::std::usize::MAX - 1;
pub const VK_SUBPASS_EXTERNAL: usize = ::std::usize::MAX;
pub const VK_MAX_DEVICE_GROUP_SIZE_KHX: usize = 32;
pub type Display = i64;
pub type VisualID = i64;
pub type Window = i64;
pub type RROutput = i64;
pub type ANativeWindow = i64;
pub type MirConnection = i64;
pub type MirSurface = i64;
pub type wl_display = i64;
pub type wl_surface = i64;
pub type HINSTANCE = i64;
pub type HWND = i64;
pub type HANDLE = i64;
pub type SECURITY_ATTRIBUTES = i64;
pub type DWORD = i64;
pub type LPCWSTR = i64;
pub type xcb_connection_t = i64;
pub type xcb_visualid_t = i64;
pub type xcb_window_t = i64;
pub type void = i64;
pub type char = i64;
pub type float = i64;
pub type uint8_t = i64;
pub type uint32_t = i64;
pub type uint64_t = i64;
pub type int32_t = i64;
pub type size_t = i64;
pub type VkFramebufferCreateFlags = i32;
pub type VkQueryPoolCreateFlags = i32;
pub type VkRenderPassCreateFlags = i32;
pub type VkSamplerCreateFlags = i32;
pub type VkPipelineLayoutCreateFlags = i32;
pub type VkPipelineCacheCreateFlags = i32;
pub type VkPipelineDepthStencilStateCreateFlags = i32;
pub type VkPipelineDynamicStateCreateFlags = i32;
pub type VkPipelineColorBlendStateCreateFlags = i32;
pub type VkPipelineMultisampleStateCreateFlags = i32;
pub type VkPipelineRasterizationStateCreateFlags = i32;
pub type VkPipelineViewportStateCreateFlags = i32;
pub type VkPipelineTessellationStateCreateFlags = i32;
pub type VkPipelineInputAssemblyStateCreateFlags = i32;
pub type VkPipelineVertexInputStateCreateFlags = i32;
pub type VkPipelineShaderStageCreateFlags = i32;
pub type VkDescriptorSetLayoutCreateFlags = i32;
pub type VkBufferViewCreateFlags = i32;
pub type VkInstanceCreateFlags = i32;
pub type VkDeviceCreateFlags = i32;
pub type VkDeviceQueueCreateFlags = i32;
pub type VkQueueFlags = i32;
pub type VkMemoryPropertyFlags = i32;
pub type VkMemoryHeapFlags = i32;
pub type VkAccessFlags = i32;
pub type VkBufferUsageFlags = i32;
pub type VkBufferCreateFlags = i32;
pub type VkShaderStageFlags = i32;
pub type VkImageUsageFlags = i32;
pub type VkImageCreateFlags = i32;
pub type VkImageViewCreateFlags = i32;
pub type VkPipelineCreateFlags = i32;
pub type VkColorComponentFlags = i32;
pub type VkFenceCreateFlags = i32;
pub type VkSemaphoreCreateFlags = i32;
pub type VkFormatFeatureFlags = i32;
pub type VkQueryControlFlags = i32;
pub type VkQueryResultFlags = i32;
pub type VkShaderModuleCreateFlags = i32;
pub type VkEventCreateFlags = i32;
pub type VkCommandPoolCreateFlags = i32;
pub type VkCommandPoolResetFlags = i32;
pub type VkCommandBufferResetFlags = i32;
pub type VkCommandBufferUsageFlags = i32;
pub type VkQueryPipelineStatisticFlags = i32;
pub type VkMemoryMapFlags = i32;
pub type VkImageAspectFlags = i32;
pub type VkSparseMemoryBindFlags = i32;
pub type VkSparseImageFormatFlags = i32;
pub type VkSubpassDescriptionFlags = i32;
pub type VkPipelineStageFlags = i32;
pub type VkSampleCountFlags = i32;
pub type VkAttachmentDescriptionFlags = i32;
pub type VkStencilFaceFlags = i32;
pub type VkCullModeFlags = i32;
pub type VkDescriptorPoolCreateFlags = i32;
pub type VkDescriptorPoolResetFlags = i32;
pub type VkDependencyFlags = i32;
pub type VkIndirectCommandsLayoutUsageFlagsNVX = i32;
pub type VkObjectEntryUsageFlagsNVX = i32;
pub type VkDescriptorUpdateTemplateCreateFlagsKHR = i32;
pub type VkCompositeAlphaFlagsKHR = i32;
pub type VkDisplayPlaneAlphaFlagsKHR = i32;
pub type VkSurfaceTransformFlagsKHR = i32;
pub type VkSwapchainCreateFlagsKHR = i32;
pub type VkDisplayModeCreateFlagsKHR = i32;
pub type VkDisplaySurfaceCreateFlagsKHR = i32;
pub type VkAndroidSurfaceCreateFlagsKHR = i32;
pub type VkMirSurfaceCreateFlagsKHR = i32;
pub type VkViSurfaceCreateFlagsNN = i32;
pub type VkWaylandSurfaceCreateFlagsKHR = i32;
pub type VkWin32SurfaceCreateFlagsKHR = i32;
pub type VkXlibSurfaceCreateFlagsKHR = i32;
pub type VkXcbSurfaceCreateFlagsKHR = i32;
pub type VkIOSSurfaceCreateFlagsMVK = i32;
pub type VkMacOSSurfaceCreateFlagsMVK = i32;
pub type VkPeerMemoryFeatureFlagsKHX = i32;
pub type VkMemoryAllocateFlagsKHX = i32;
pub type VkDeviceGroupPresentModeFlagsKHX = i32;
pub type VkDebugReportFlagsEXT = i32;
pub type VkCommandPoolTrimFlagsKHR = i32;
pub type VkExternalMemoryHandleTypeFlagsNV = i32;
pub type VkExternalMemoryFeatureFlagsNV = i32;
pub type VkExternalMemoryHandleTypeFlagsKHX = i32;
pub type VkExternalMemoryFeatureFlagsKHX = i32;
pub type VkExternalSemaphoreHandleTypeFlagsKHX = i32;
pub type VkExternalSemaphoreFeatureFlagsKHX = i32;
pub type VkSurfaceCounterFlagsEXT = i32;
pub type VkPipelineViewportSwizzleStateCreateFlagsNV = i32;
pub type VkPipelineDiscardRectangleStateCreateFlagsEXT = i32;
pub type VkInstance = i64;
pub type VkPhysicalDevice = i64;
pub type VkDevice = i64;
pub type VkQueue = i64;
pub type VkCommandBuffer = i64;
pub type VkDeviceMemory = i64;
pub type VkCommandPool = i64;
pub type VkBuffer = i64;
pub type VkBufferView = i64;
pub type VkImage = i64;
pub type VkImageView = i64;
pub type VkShaderModule = i64;
pub type VkPipeline = i64;
pub type VkPipelineLayout = i64;
pub type VkSampler = i64;
pub type VkDescriptorSet = i64;
pub type VkDescriptorSetLayout = i64;
pub type VkDescriptorPool = i64;
pub type VkFence = i64;
pub type VkSemaphore = i64;
pub type VkEvent = i64;
pub type VkQueryPool = i64;
pub type VkFramebuffer = i64;
pub type VkRenderPass = i64;
pub type VkPipelineCache = i64;
pub type VkObjectTableNVX = i64;
pub type VkIndirectCommandsLayoutNVX = i64;
pub type VkDescriptorUpdateTemplateKHR = i64;
pub type VkDisplayKHR = i64;
pub type VkDisplayModeKHR = i64;
pub type VkSurfaceKHR = i64;
pub type VkSwapchainKHR = i64;
pub type VkDebugReportCallbackEXT = i64;
#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkImageLayout {
	VK_IMAGE_LAYOUT_UNDEFINED = 0,
	VK_IMAGE_LAYOUT_GENERAL = 1,
	VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
	VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
	VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
	VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
	VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
	VK_IMAGE_LAYOUT_PREINITIALIZED = 8,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkAttachmentLoadOp {
	VK_ATTACHMENT_LOAD_OP_LOAD = 0,
	VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
	VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkAttachmentStoreOp {
	VK_ATTACHMENT_STORE_OP_STORE = 0,
	VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkImageType {
	VK_IMAGE_TYPE_1D = 0,
	VK_IMAGE_TYPE_2D = 1,
	VK_IMAGE_TYPE_3D = 2,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkImageTiling {
	VK_IMAGE_TILING_OPTIMAL = 0,
	VK_IMAGE_TILING_LINEAR = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkImageViewType {
	VK_IMAGE_VIEW_TYPE_1D = 0,
	VK_IMAGE_VIEW_TYPE_2D = 1,
	VK_IMAGE_VIEW_TYPE_3D = 2,
	VK_IMAGE_VIEW_TYPE_CUBE = 3,
	VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
	VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
	VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkCommandBufferLevel {
	VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
	VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkComponentSwizzle {
	VK_COMPONENT_SWIZZLE_IDENTITY = 0,
	VK_COMPONENT_SWIZZLE_ZERO = 1,
	VK_COMPONENT_SWIZZLE_ONE = 2,
	VK_COMPONENT_SWIZZLE_R = 3,
	VK_COMPONENT_SWIZZLE_G = 4,
	VK_COMPONENT_SWIZZLE_B = 5,
	VK_COMPONENT_SWIZZLE_A = 6,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDescriptorType {
	VK_DESCRIPTOR_TYPE_SAMPLER = 0,
	VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
	VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
	VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
	VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
	VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
	VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
	VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
	VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkQueryType {
	VK_QUERY_TYPE_OCCLUSION = 0,
	VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
	VK_QUERY_TYPE_TIMESTAMP = 2,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkBorderColor {
	VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
	VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
	VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
	VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
	VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
	VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkPipelineBindPoint {
	VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
	VK_PIPELINE_BIND_POINT_COMPUTE = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkPipelineCacheHeaderVersion {
	VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkPrimitiveTopology {
	VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
	VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
	VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
	VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
	VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkSharingMode {
	VK_SHARING_MODE_EXCLUSIVE = 0,
	VK_SHARING_MODE_CONCURRENT = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkIndexType {
	VK_INDEX_TYPE_UINT16 = 0,
	VK_INDEX_TYPE_UINT32 = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkFilter {
	VK_FILTER_NEAREST = 0,
	VK_FILTER_LINEAR = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkSamplerMipmapMode {
	VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
	VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkSamplerAddressMode {
	VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
	VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
	VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkCompareOp {
	VK_COMPARE_OP_NEVER = 0,
	VK_COMPARE_OP_LESS = 1,
	VK_COMPARE_OP_EQUAL = 2,
	VK_COMPARE_OP_LESS_OR_EQUAL = 3,
	VK_COMPARE_OP_GREATER = 4,
	VK_COMPARE_OP_NOT_EQUAL = 5,
	VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
	VK_COMPARE_OP_ALWAYS = 7,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkPolygonMode {
	VK_POLYGON_MODE_FILL = 0,
	VK_POLYGON_MODE_LINE = 1,
	VK_POLYGON_MODE_POINT = 2,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkFrontFace {
	VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
	VK_FRONT_FACE_CLOCKWISE = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkBlendFactor {
	VK_BLEND_FACTOR_ZERO = 0,
	VK_BLEND_FACTOR_ONE = 1,
	VK_BLEND_FACTOR_SRC_COLOR = 2,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
	VK_BLEND_FACTOR_DST_COLOR = 4,
	VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
	VK_BLEND_FACTOR_SRC_ALPHA = 6,
	VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
	VK_BLEND_FACTOR_DST_ALPHA = 8,
	VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
	VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
	VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
	VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
	VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
	VK_BLEND_FACTOR_SRC1_COLOR = 15,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
	VK_BLEND_FACTOR_SRC1_ALPHA = 17,
	VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkBlendOp {
	VK_BLEND_OP_ADD = 0,
	VK_BLEND_OP_SUBTRACT = 1,
	VK_BLEND_OP_REVERSE_SUBTRACT = 2,
	VK_BLEND_OP_MIN = 3,
	VK_BLEND_OP_MAX = 4,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkStencilOp {
	VK_STENCIL_OP_KEEP = 0,
	VK_STENCIL_OP_ZERO = 1,
	VK_STENCIL_OP_REPLACE = 2,
	VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
	VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
	VK_STENCIL_OP_INVERT = 5,
	VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
	VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkLogicOp {
	VK_LOGIC_OP_CLEAR = 0,
	VK_LOGIC_OP_AND = 1,
	VK_LOGIC_OP_AND_REVERSE = 2,
	VK_LOGIC_OP_COPY = 3,
	VK_LOGIC_OP_AND_INVERTED = 4,
	VK_LOGIC_OP_NO_OP = 5,
	VK_LOGIC_OP_XOR = 6,
	VK_LOGIC_OP_OR = 7,
	VK_LOGIC_OP_NOR = 8,
	VK_LOGIC_OP_EQUIVALENT = 9,
	VK_LOGIC_OP_INVERT = 10,
	VK_LOGIC_OP_OR_REVERSE = 11,
	VK_LOGIC_OP_COPY_INVERTED = 12,
	VK_LOGIC_OP_OR_INVERTED = 13,
	VK_LOGIC_OP_NAND = 14,
	VK_LOGIC_OP_SET = 15,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkInternalAllocationType {
	VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkSystemAllocationScope {
	VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
	VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
	VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
	VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
	VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkPhysicalDeviceType {
	VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
	VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
	VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
	VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
	VK_PHYSICAL_DEVICE_TYPE_CPU = 4,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkVertexInputRate {
	VK_VERTEX_INPUT_RATE_VERTEX = 0,
	VK_VERTEX_INPUT_RATE_INSTANCE = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkFormat {
	VK_FORMAT_UNDEFINED = 0,
	VK_FORMAT_R4G4_UNORM_PACK8 = 1,
	VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
	VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
	VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
	VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
	VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
	VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
	VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
	VK_FORMAT_R8_UNORM = 9,
	VK_FORMAT_R8_SNORM = 10,
	VK_FORMAT_R8_USCALED = 11,
	VK_FORMAT_R8_SSCALED = 12,
	VK_FORMAT_R8_UINT = 13,
	VK_FORMAT_R8_SINT = 14,
	VK_FORMAT_R8_SRGB = 15,
	VK_FORMAT_R8G8_UNORM = 16,
	VK_FORMAT_R8G8_SNORM = 17,
	VK_FORMAT_R8G8_USCALED = 18,
	VK_FORMAT_R8G8_SSCALED = 19,
	VK_FORMAT_R8G8_UINT = 20,
	VK_FORMAT_R8G8_SINT = 21,
	VK_FORMAT_R8G8_SRGB = 22,
	VK_FORMAT_R8G8B8_UNORM = 23,
	VK_FORMAT_R8G8B8_SNORM = 24,
	VK_FORMAT_R8G8B8_USCALED = 25,
	VK_FORMAT_R8G8B8_SSCALED = 26,
	VK_FORMAT_R8G8B8_UINT = 27,
	VK_FORMAT_R8G8B8_SINT = 28,
	VK_FORMAT_R8G8B8_SRGB = 29,
	VK_FORMAT_B8G8R8_UNORM = 30,
	VK_FORMAT_B8G8R8_SNORM = 31,
	VK_FORMAT_B8G8R8_USCALED = 32,
	VK_FORMAT_B8G8R8_SSCALED = 33,
	VK_FORMAT_B8G8R8_UINT = 34,
	VK_FORMAT_B8G8R8_SINT = 35,
	VK_FORMAT_B8G8R8_SRGB = 36,
	VK_FORMAT_R8G8B8A8_UNORM = 37,
	VK_FORMAT_R8G8B8A8_SNORM = 38,
	VK_FORMAT_R8G8B8A8_USCALED = 39,
	VK_FORMAT_R8G8B8A8_SSCALED = 40,
	VK_FORMAT_R8G8B8A8_UINT = 41,
	VK_FORMAT_R8G8B8A8_SINT = 42,
	VK_FORMAT_R8G8B8A8_SRGB = 43,
	VK_FORMAT_B8G8R8A8_UNORM = 44,
	VK_FORMAT_B8G8R8A8_SNORM = 45,
	VK_FORMAT_B8G8R8A8_USCALED = 46,
	VK_FORMAT_B8G8R8A8_SSCALED = 47,
	VK_FORMAT_B8G8R8A8_UINT = 48,
	VK_FORMAT_B8G8R8A8_SINT = 49,
	VK_FORMAT_B8G8R8A8_SRGB = 50,
	VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
	VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
	VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
	VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
	VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
	VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
	VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
	VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
	VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
	VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
	VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
	VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
	VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
	VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
	VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
	VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
	VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
	VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
	VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
	VK_FORMAT_R16_UNORM = 70,
	VK_FORMAT_R16_SNORM = 71,
	VK_FORMAT_R16_USCALED = 72,
	VK_FORMAT_R16_SSCALED = 73,
	VK_FORMAT_R16_UINT = 74,
	VK_FORMAT_R16_SINT = 75,
	VK_FORMAT_R16_SFLOAT = 76,
	VK_FORMAT_R16G16_UNORM = 77,
	VK_FORMAT_R16G16_SNORM = 78,
	VK_FORMAT_R16G16_USCALED = 79,
	VK_FORMAT_R16G16_SSCALED = 80,
	VK_FORMAT_R16G16_UINT = 81,
	VK_FORMAT_R16G16_SINT = 82,
	VK_FORMAT_R16G16_SFLOAT = 83,
	VK_FORMAT_R16G16B16_UNORM = 84,
	VK_FORMAT_R16G16B16_SNORM = 85,
	VK_FORMAT_R16G16B16_USCALED = 86,
	VK_FORMAT_R16G16B16_SSCALED = 87,
	VK_FORMAT_R16G16B16_UINT = 88,
	VK_FORMAT_R16G16B16_SINT = 89,
	VK_FORMAT_R16G16B16_SFLOAT = 90,
	VK_FORMAT_R16G16B16A16_UNORM = 91,
	VK_FORMAT_R16G16B16A16_SNORM = 92,
	VK_FORMAT_R16G16B16A16_USCALED = 93,
	VK_FORMAT_R16G16B16A16_SSCALED = 94,
	VK_FORMAT_R16G16B16A16_UINT = 95,
	VK_FORMAT_R16G16B16A16_SINT = 96,
	VK_FORMAT_R16G16B16A16_SFLOAT = 97,
	VK_FORMAT_R32_UINT = 98,
	VK_FORMAT_R32_SINT = 99,
	VK_FORMAT_R32_SFLOAT = 100,
	VK_FORMAT_R32G32_UINT = 101,
	VK_FORMAT_R32G32_SINT = 102,
	VK_FORMAT_R32G32_SFLOAT = 103,
	VK_FORMAT_R32G32B32_UINT = 104,
	VK_FORMAT_R32G32B32_SINT = 105,
	VK_FORMAT_R32G32B32_SFLOAT = 106,
	VK_FORMAT_R32G32B32A32_UINT = 107,
	VK_FORMAT_R32G32B32A32_SINT = 108,
	VK_FORMAT_R32G32B32A32_SFLOAT = 109,
	VK_FORMAT_R64_UINT = 110,
	VK_FORMAT_R64_SINT = 111,
	VK_FORMAT_R64_SFLOAT = 112,
	VK_FORMAT_R64G64_UINT = 113,
	VK_FORMAT_R64G64_SINT = 114,
	VK_FORMAT_R64G64_SFLOAT = 115,
	VK_FORMAT_R64G64B64_UINT = 116,
	VK_FORMAT_R64G64B64_SINT = 117,
	VK_FORMAT_R64G64B64_SFLOAT = 118,
	VK_FORMAT_R64G64B64A64_UINT = 119,
	VK_FORMAT_R64G64B64A64_SINT = 120,
	VK_FORMAT_R64G64B64A64_SFLOAT = 121,
	VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
	VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
	VK_FORMAT_D16_UNORM = 124,
	VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
	VK_FORMAT_D32_SFLOAT = 126,
	VK_FORMAT_S8_UINT = 127,
	VK_FORMAT_D16_UNORM_S8_UINT = 128,
	VK_FORMAT_D24_UNORM_S8_UINT = 129,
	VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
	VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
	VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
	VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
	VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
	VK_FORMAT_BC2_UNORM_BLOCK = 135,
	VK_FORMAT_BC2_SRGB_BLOCK = 136,
	VK_FORMAT_BC3_UNORM_BLOCK = 137,
	VK_FORMAT_BC3_SRGB_BLOCK = 138,
	VK_FORMAT_BC4_UNORM_BLOCK = 139,
	VK_FORMAT_BC4_SNORM_BLOCK = 140,
	VK_FORMAT_BC5_UNORM_BLOCK = 141,
	VK_FORMAT_BC5_SNORM_BLOCK = 142,
	VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
	VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
	VK_FORMAT_BC7_UNORM_BLOCK = 145,
	VK_FORMAT_BC7_SRGB_BLOCK = 146,
	VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
	VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
	VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
	VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
	VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
	VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
	VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
	VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
	VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
	VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
	VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
	VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
	VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
	VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
	VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
	VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
	VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
	VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
	VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
	VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
	VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
	VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
	VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
	VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
	VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
	VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
	VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
	VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
	VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
	VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
	VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
	VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
	VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
	VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
	VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
	VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
	VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
	VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkStructureType {
	VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
	VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
	VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
	VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
	VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
	VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
	VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
	VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
	VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
	VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
	VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
	VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
	VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
	VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
	VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
	VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
	VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
	VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
	VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
	VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
	VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
	VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
	VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
	VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
	VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
	VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
	VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
	VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
	VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
	VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
	VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
	VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
	VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
	VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
	VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
	VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
	VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
	VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
	VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
	VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
	VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
	VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
	VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
	VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
	VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
	VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkSubpassContents {
	VK_SUBPASS_CONTENTS_INLINE = 0,
	VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkResult {
	VK_SUCCESS = 0,
	VK_NOT_READY = 1,
	VK_TIMEOUT = 2,
	VK_EVENT_SET = 3,
	VK_EVENT_RESET = 4,
	VK_INCOMPLETE = 5,
	VK_ERROR_OUT_OF_HOST_MEMORY = -1,
	VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
	VK_ERROR_INITIALIZATION_FAILED = -3,
	VK_ERROR_DEVICE_LOST = -4,
	VK_ERROR_MEMORY_MAP_FAILED = -5,
	VK_ERROR_LAYER_NOT_PRESENT = -6,
	VK_ERROR_EXTENSION_NOT_PRESENT = -7,
	VK_ERROR_FEATURE_NOT_PRESENT = -8,
	VK_ERROR_INCOMPATIBLE_DRIVER = -9,
	VK_ERROR_TOO_MANY_OBJECTS = -10,
	VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
	VK_ERROR_FRAGMENTED_POOL = -12,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDynamicState {
	VK_DYNAMIC_STATE_VIEWPORT = 0,
	VK_DYNAMIC_STATE_SCISSOR = 1,
	VK_DYNAMIC_STATE_LINE_WIDTH = 2,
	VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
	VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
	VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
	VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
	VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
	VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDescriptorUpdateTemplateTypeKHR {
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0,
	VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkPresentModeKHR {
	VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
	VK_PRESENT_MODE_MAILBOX_KHR = 1,
	VK_PRESENT_MODE_FIFO_KHR = 2,
	VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkColorSpaceKHR {
	VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDebugReportObjectTypeEXT {
	VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
	VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
	VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
	VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
	VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
	VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
	VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
	VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
	VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
	VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
	VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
	VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
	VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
	VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
	VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
	VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
	VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
	VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
	VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = 28,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
	VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
	VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31,
	VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDebugReportErrorEXT {
	VK_DEBUG_REPORT_ERROR_NONE_EXT = 0,
	VK_DEBUG_REPORT_ERROR_CALLBACK_REF_EXT = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkRasterizationOrderAMD {
	VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
	VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkValidationCheckEXT {
	VK_VALIDATION_CHECK_ALL_EXT = 0,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkIndirectCommandsTokenTypeNVX {
	VK_INDIRECT_COMMANDS_TOKEN_PIPELINE_NVX = 0,
	VK_INDIRECT_COMMANDS_TOKEN_DESCRIPTOR_SET_NVX = 1,
	VK_INDIRECT_COMMANDS_TOKEN_INDEX_BUFFER_NVX = 2,
	VK_INDIRECT_COMMANDS_TOKEN_VERTEX_BUFFER_NVX = 3,
	VK_INDIRECT_COMMANDS_TOKEN_PUSH_CONSTANT_NVX = 4,
	VK_INDIRECT_COMMANDS_TOKEN_DRAW_INDEXED_NVX = 5,
	VK_INDIRECT_COMMANDS_TOKEN_DRAW_NVX = 6,
	VK_INDIRECT_COMMANDS_TOKEN_DISPATCH_NVX = 7,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkObjectEntryTypeNVX {
	VK_OBJECT_ENTRY_DESCRIPTOR_SET_NVX = 0,
	VK_OBJECT_ENTRY_PIPELINE_NVX = 1,
	VK_OBJECT_ENTRY_INDEX_BUFFER_NVX = 2,
	VK_OBJECT_ENTRY_VERTEX_BUFFER_NVX = 3,
	VK_OBJECT_ENTRY_PUSH_CONSTANT_NVX = 4,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDisplayPowerStateEXT {
	VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
	VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
	VK_DISPLAY_POWER_STATE_ON_EXT = 2,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDeviceEventTypeEXT {
	VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDisplayEventTypeEXT {
	VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkViewportCoordinateSwizzleNV {
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
	VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
	VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,

}

#[derive(PartialEq, Debug)]
#[repr(i32)]
pub enum VkDiscardRectangleModeEXT {
	VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
	VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,

}

bitflags! {
	pub struct VkCullModeFlagBits: u32 {
		const VK_CULL_MODE_NONE = 0;
		const VK_CULL_MODE_FRONT_BIT = 0b00000000000000000000000000000001;
		const VK_CULL_MODE_BACK_BIT = 0b00000000000000000000000000000010;
		const VK_CULL_MODE_FRONT_AND_BACK = 0x00000003;

	}
}

bitflags! {
	pub struct VkQueueFlagBits: u32 {
		const VK_QUEUE_GRAPHICS_BIT = 0b00000000000000000000000000000001;
		const VK_QUEUE_COMPUTE_BIT = 0b00000000000000000000000000000010;
		const VK_QUEUE_TRANSFER_BIT = 0b00000000000000000000000000000100;
		const VK_QUEUE_SPARSE_BINDING_BIT = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkMemoryPropertyFlagBits: u32 {
		const VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 0b00000000000000000000000000000001;
		const VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 0b00000000000000000000000000000010;
		const VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 0b00000000000000000000000000000100;
		const VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 0b00000000000000000000000000001000;
		const VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 0b00000000000000000000000000010000;

	}
}

bitflags! {
	pub struct VkMemoryHeapFlagBits: u32 {
		const VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkAccessFlagBits: u32 {
		const VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 0b00000000000000000000000000000001;
		const VK_ACCESS_INDEX_READ_BIT = 0b00000000000000000000000000000010;
		const VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 0b00000000000000000000000000000100;
		const VK_ACCESS_UNIFORM_READ_BIT = 0b00000000000000000000000000001000;
		const VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 0b00000000000000000000000000010000;
		const VK_ACCESS_SHADER_READ_BIT = 0b00000000000000000000000000100000;
		const VK_ACCESS_SHADER_WRITE_BIT = 0b00000000000000000000000001000000;
		const VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 0b00000000000000000000000010000000;
		const VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 0b00000000000000000000000100000000;
		const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 0b00000000000000000000001000000000;
		const VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 0b00000000000000000000010000000000;
		const VK_ACCESS_TRANSFER_READ_BIT = 0b00000000000000000000100000000000;
		const VK_ACCESS_TRANSFER_WRITE_BIT = 0b00000000000000000001000000000000;
		const VK_ACCESS_HOST_READ_BIT = 0b00000000000000000010000000000000;
		const VK_ACCESS_HOST_WRITE_BIT = 0b00000000000000000100000000000000;
		const VK_ACCESS_MEMORY_READ_BIT = 0b00000000000000001000000000000000;
		const VK_ACCESS_MEMORY_WRITE_BIT = 0b00000000000000010000000000000000;

	}
}

bitflags! {
	pub struct VkBufferUsageFlagBits: u32 {
		const VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 0b00000000000000000000000000000001;
		const VK_BUFFER_USAGE_TRANSFER_DST_BIT = 0b00000000000000000000000000000010;
		const VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 0b00000000000000000000000000000100;
		const VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 0b00000000000000000000000000001000;
		const VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 0b00000000000000000000000000010000;
		const VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 0b00000000000000000000000000100000;
		const VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 0b00000000000000000000000001000000;
		const VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 0b00000000000000000000000010000000;
		const VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 0b00000000000000000000000100000000;

	}
}

bitflags! {
	pub struct VkBufferCreateFlagBits: u32 {
		const VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 0b00000000000000000000000000000001;
		const VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 0b00000000000000000000000000000010;
		const VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 0b00000000000000000000000000000100;

	}
}

bitflags! {
	pub struct VkShaderStageFlagBits: u32 {
		const VK_SHADER_STAGE_VERTEX_BIT = 0b00000000000000000000000000000001;
		const VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 0b00000000000000000000000000000010;
		const VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 0b00000000000000000000000000000100;
		const VK_SHADER_STAGE_GEOMETRY_BIT = 0b00000000000000000000000000001000;
		const VK_SHADER_STAGE_FRAGMENT_BIT = 0b00000000000000000000000000010000;
		const VK_SHADER_STAGE_COMPUTE_BIT = 0b00000000000000000000000000100000;
		const VK_SHADER_STAGE_ALL_GRAPHICS = 0x0000001F;
		const VK_SHADER_STAGE_ALL = 0x7FFFFFFF;

	}
}

bitflags! {
	pub struct VkImageUsageFlagBits: u32 {
		const VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 0b00000000000000000000000000000001;
		const VK_IMAGE_USAGE_TRANSFER_DST_BIT = 0b00000000000000000000000000000010;
		const VK_IMAGE_USAGE_SAMPLED_BIT = 0b00000000000000000000000000000100;
		const VK_IMAGE_USAGE_STORAGE_BIT = 0b00000000000000000000000000001000;
		const VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 0b00000000000000000000000000010000;
		const VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 0b00000000000000000000000000100000;
		const VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 0b00000000000000000000000001000000;
		const VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 0b00000000000000000000000010000000;

	}
}

bitflags! {
	pub struct VkImageCreateFlagBits: u32 {
		const VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 0b00000000000000000000000000000001;
		const VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 0b00000000000000000000000000000010;
		const VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 0b00000000000000000000000000000100;
		const VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 0b00000000000000000000000000001000;
		const VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 0b00000000000000000000000000010000;

	}
}

bitflags! {
	pub struct VkPipelineCreateFlagBits: u32 {
		const VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 0b00000000000000000000000000000001;
		const VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 0b00000000000000000000000000000010;
		const VK_PIPELINE_CREATE_DERIVATIVE_BIT = 0b00000000000000000000000000000100;

	}
}

bitflags! {
	pub struct VkColorComponentFlagBits: u32 {
		const VK_COLOR_COMPONENT_R_BIT = 0b00000000000000000000000000000001;
		const VK_COLOR_COMPONENT_G_BIT = 0b00000000000000000000000000000010;
		const VK_COLOR_COMPONENT_B_BIT = 0b00000000000000000000000000000100;
		const VK_COLOR_COMPONENT_A_BIT = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkFenceCreateFlagBits: u32 {
		const VK_FENCE_CREATE_SIGNALED_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkFormatFeatureFlagBits: u32 {
		const VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 0b00000000000000000000000000000001;
		const VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 0b00000000000000000000000000000010;
		const VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 0b00000000000000000000000000000100;
		const VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 0b00000000000000000000000000001000;
		const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 0b00000000000000000000000000010000;
		const VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 0b00000000000000000000000000100000;
		const VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 0b00000000000000000000000001000000;
		const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 0b00000000000000000000000010000000;
		const VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 0b00000000000000000000000100000000;
		const VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 0b00000000000000000000001000000000;
		const VK_FORMAT_FEATURE_BLIT_SRC_BIT = 0b00000000000000000000010000000000;
		const VK_FORMAT_FEATURE_BLIT_DST_BIT = 0b00000000000000000000100000000000;
		const VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 0b00000000000000000001000000000000;

	}
}

bitflags! {
	pub struct VkQueryControlFlagBits: u32 {
		const VK_QUERY_CONTROL_PRECISE_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkQueryResultFlagBits: u32 {
		const VK_QUERY_RESULT_64_BIT = 0b00000000000000000000000000000001;
		const VK_QUERY_RESULT_WAIT_BIT = 0b00000000000000000000000000000010;
		const VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 0b00000000000000000000000000000100;
		const VK_QUERY_RESULT_PARTIAL_BIT = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkCommandBufferUsageFlagBits: u32 {
		const VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 0b00000000000000000000000000000001;
		const VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 0b00000000000000000000000000000010;
		const VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 0b00000000000000000000000000000100;

	}
}

bitflags! {
	pub struct VkQueryPipelineStatisticFlagBits: u32 {
		const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 0b00000000000000000000000000000001;
		const VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 0b00000000000000000000000000000010;
		const VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 0b00000000000000000000000000000100;
		const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 0b00000000000000000000000000001000;
		const VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 0b00000000000000000000000000010000;
		const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 0b00000000000000000000000000100000;
		const VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 0b00000000000000000000000001000000;
		const VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 0b00000000000000000000000010000000;
		const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 0b00000000000000000000000100000000;
		const VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT = 0b00000000000000000000001000000000;
		const VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 0b00000000000000000000010000000000;

	}
}

bitflags! {
	pub struct VkImageAspectFlagBits: u32 {
		const VK_IMAGE_ASPECT_COLOR_BIT = 0b00000000000000000000000000000001;
		const VK_IMAGE_ASPECT_DEPTH_BIT = 0b00000000000000000000000000000010;
		const VK_IMAGE_ASPECT_STENCIL_BIT = 0b00000000000000000000000000000100;
		const VK_IMAGE_ASPECT_METADATA_BIT = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkSparseImageFormatFlagBits: u32 {
		const VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 0b00000000000000000000000000000001;
		const VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 0b00000000000000000000000000000010;
		const VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 0b00000000000000000000000000000100;

	}
}

bitflags! {
	pub struct VkSparseMemoryBindFlagBits: u32 {
		const VK_SPARSE_MEMORY_BIND_METADATA_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkPipelineStageFlagBits: u32 {
		const VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 0b00000000000000000000000000000001;
		const VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 0b00000000000000000000000000000010;
		const VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 0b00000000000000000000000000000100;
		const VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 0b00000000000000000000000000001000;
		const VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 0b00000000000000000000000000010000;
		const VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 0b00000000000000000000000000100000;
		const VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 0b00000000000000000000000001000000;
		const VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 0b00000000000000000000000010000000;
		const VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 0b00000000000000000000000100000000;
		const VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 0b00000000000000000000001000000000;
		const VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 0b00000000000000000000010000000000;
		const VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 0b00000000000000000000100000000000;
		const VK_PIPELINE_STAGE_TRANSFER_BIT = 0b00000000000000000001000000000000;
		const VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 0b00000000000000000010000000000000;
		const VK_PIPELINE_STAGE_HOST_BIT = 0b00000000000000000100000000000000;
		const VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 0b00000000000000001000000000000000;
		const VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 0b00000000000000010000000000000000;

	}
}

bitflags! {
	pub struct VkCommandPoolCreateFlagBits: u32 {
		const VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 0b00000000000000000000000000000001;
		const VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 0b00000000000000000000000000000010;

	}
}

bitflags! {
	pub struct VkCommandPoolResetFlagBits: u32 {
		const VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkCommandBufferResetFlagBits: u32 {
		const VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkSampleCountFlagBits: u32 {
		const VK_SAMPLE_COUNT_1_BIT = 0b00000000000000000000000000000001;
		const VK_SAMPLE_COUNT_2_BIT = 0b00000000000000000000000000000010;
		const VK_SAMPLE_COUNT_4_BIT = 0b00000000000000000000000000000100;
		const VK_SAMPLE_COUNT_8_BIT = 0b00000000000000000000000000001000;
		const VK_SAMPLE_COUNT_16_BIT = 0b00000000000000000000000000010000;
		const VK_SAMPLE_COUNT_32_BIT = 0b00000000000000000000000000100000;
		const VK_SAMPLE_COUNT_64_BIT = 0b00000000000000000000000001000000;

	}
}

bitflags! {
	pub struct VkAttachmentDescriptionFlagBits: u32 {
		const VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkStencilFaceFlagBits: u32 {
		const VK_STENCIL_FACE_FRONT_BIT = 0b00000000000000000000000000000001;
		const VK_STENCIL_FACE_BACK_BIT = 0b00000000000000000000000000000010;
		const VK_STENCIL_FRONT_AND_BACK = 0x00000003;

	}
}

bitflags! {
	pub struct VkDescriptorPoolCreateFlagBits: u32 {
		const VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkDependencyFlagBits: u32 {
		const VK_DEPENDENCY_BY_REGION_BIT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkDisplayPlaneAlphaFlagBitsKHR: u32 {
		const VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 0b00000000000000000000000000000001;
		const VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 0b00000000000000000000000000000010;
		const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 0b00000000000000000000000000000100;
		const VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkCompositeAlphaFlagBitsKHR: u32 {
		const VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 0b00000000000000000000000000000001;
		const VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 0b00000000000000000000000000000010;
		const VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 0b00000000000000000000000000000100;
		const VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkSurfaceTransformFlagBitsKHR: u32 {
		const VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 0b00000000000000000000000000000001;
		const VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 0b00000000000000000000000000000010;
		const VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 0b00000000000000000000000000000100;
		const VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 0b00000000000000000000000000001000;
		const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 0b00000000000000000000000000010000;
		const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 0b00000000000000000000000000100000;
		const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 0b00000000000000000000000001000000;
		const VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 0b00000000000000000000000010000000;
		const VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 0b00000000000000000000000100000000;

	}
}

bitflags! {
	pub struct VkDebugReportFlagBitsEXT: u32 {
		const VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 0b00000000000000000000000000000001;
		const VK_DEBUG_REPORT_WARNING_BIT_EXT = 0b00000000000000000000000000000010;
		const VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 0b00000000000000000000000000000100;
		const VK_DEBUG_REPORT_ERROR_BIT_EXT = 0b00000000000000000000000000001000;
		const VK_DEBUG_REPORT_DEBUG_BIT_EXT = 0b00000000000000000000000000010000;

	}
}

bitflags! {
	pub struct VkExternalMemoryHandleTypeFlagBitsNV: u32 {
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 0b00000000000000000000000000000001;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 0b00000000000000000000000000000010;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 0b00000000000000000000000000000100;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkExternalMemoryFeatureFlagBitsNV: u32 {
		const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 0b00000000000000000000000000000001;
		const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 0b00000000000000000000000000000010;
		const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 0b00000000000000000000000000000100;

	}
}

bitflags! {
	pub struct VkIndirectCommandsLayoutUsageFlagBitsNVX: u32 {
		const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 0b00000000000000000000000000000001;
		const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 0b00000000000000000000000000000010;
		const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 0b00000000000000000000000000000100;
		const VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkObjectEntryUsageFlagBitsNVX: u32 {
		const VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 0b00000000000000000000000000000001;
		const VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 0b00000000000000000000000000000010;

	}
}

bitflags! {
	pub struct VkExternalMemoryHandleTypeFlagBitsKHX: u32 {
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHX = 0b00000000000000000000000000000001;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHX = 0b00000000000000000000000000000010;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHX = 0b00000000000000000000000000000100;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHX = 0b00000000000000000000000000001000;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHX = 0b00000000000000000000000000010000;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHX = 0b00000000000000000000000000100000;
		const VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHX = 0b00000000000000000000000001000000;

	}
}

bitflags! {
	pub struct VkExternalMemoryFeatureFlagBitsKHX: u32 {
		const VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHX = 0b00000000000000000000000000000001;
		const VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHX = 0b00000000000000000000000000000010;
		const VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHX = 0b00000000000000000000000000000100;

	}
}

bitflags! {
	pub struct VkExternalSemaphoreHandleTypeFlagBitsKHX: u32 {
		const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHX = 0b00000000000000000000000000000001;
		const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHX = 0b00000000000000000000000000000010;
		const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHX = 0b00000000000000000000000000000100;
		const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHX = 0b00000000000000000000000000001000;
		const VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FENCE_FD_BIT_KHX = 0b00000000000000000000000000010000;

	}
}

bitflags! {
	pub struct VkExternalSemaphoreFeatureFlagBitsKHX: u32 {
		const VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHX = 0b00000000000000000000000000000001;
		const VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHX = 0b00000000000000000000000000000010;

	}
}

bitflags! {
	pub struct VkSurfaceCounterFlagBitsEXT: u32 {
		const VK_SURFACE_COUNTER_VBLANK_EXT = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkPeerMemoryFeatureFlagBitsKHX: u32 {
		const VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX = 0b00000000000000000000000000000001;
		const VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX = 0b00000000000000000000000000000010;
		const VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX = 0b00000000000000000000000000000100;
		const VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX = 0b00000000000000000000000000001000;

	}
}

bitflags! {
	pub struct VkMemoryAllocateFlagBitsKHX: u32 {
		const VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX = 0b00000000000000000000000000000001;

	}
}

bitflags! {
	pub struct VkDeviceGroupPresentModeFlagBitsKHX: u32 {
		const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX = 0b00000000000000000000000000000001;
		const VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX = 0b00000000000000000000000000000010;
		const VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX = 0b00000000000000000000000000000100;
		const VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX = 0b00000000000000000000000000001000;

	}
}

#[repr(C)]
pub struct VkOffset2D {
	pub x:  i32,
	pub y:  i32,

}
#[repr(C)]
pub struct VkOffset3D {
	pub x:  i32,
	pub y:  i32,
	pub z:  i32,

}
#[repr(C)]
pub struct VkExtent2D {
	pub width:  u32,
	pub height:  u32,

}
#[repr(C)]
pub struct VkExtent3D {
	pub width:  u32,
	pub height:  u32,
	pub depth:  u32,

}
#[repr(C)]
pub struct VkViewport {
	pub x:  f32,
	pub y:  f32,
	pub width:  f32,
	pub height:  f32,
	pub minDepth:  f32,
	pub maxDepth:  f32,

}
#[repr(C)]
pub struct VkRect2D {
	pub offset:  VkOffset2D,
	pub extent:  VkExtent2D,

}
#[repr(C)]
pub struct VkRect3D {
	pub offset:  VkOffset3D,
	pub extent:  VkExtent3D,

}
#[repr(C)]
pub struct VkClearRect {
	pub rect:  VkRect2D,
	pub baseArrayLayer:  u32,
	pub layerCount:  u32,

}
#[repr(C)]
pub struct VkComponentMapping {
	pub r:  VkComponentSwizzle,
	pub g:  VkComponentSwizzle,
	pub b:  VkComponentSwizzle,
	pub a:  VkComponentSwizzle,

}
#[repr(C)]
pub struct VkPhysicalDeviceProperties {
	pub apiVersion:  u32,
	pub driverVersion:  u32,
	pub vendorID:  u32,
	pub deviceID:  u32,
	pub deviceType:  VkPhysicalDeviceType,
	pub deviceName: [ u8; VK_MAX_PHYSICAL_DEVICE_NAME_SIZE],
	pub pipelineCacheUUID: [ u8; VK_UUID_SIZE],
	pub limits:  VkPhysicalDeviceLimits,
	pub sparseProperties:  VkPhysicalDeviceSparseProperties,

}
#[repr(C)]
pub struct VkExtensionProperties {
	pub extensionName: [ u8; VK_MAX_EXTENSION_NAME_SIZE],
	pub specVersion:  u32,

}
#[repr(C)]
pub struct VkLayerProperties {
	pub layerName: [ u8; VK_MAX_EXTENSION_NAME_SIZE],
	pub specVersion:  u32,
	pub implementationVersion:  u32,
	pub description: [ u8; VK_MAX_DESCRIPTION_SIZE],

}
#[repr(C)]
pub struct VkApplicationInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub pApplicationName: *const u8,
	pub applicationVersion:  u32,
	pub pEngineName: *const u8,
	pub engineVersion:  u32,
	pub apiVersion:  u32,

}
#[repr(C)]
pub struct VkAllocationCallbacks {
	pub pUserData: *mut c_void,
	pub pfnAllocation:  PFN_vkAllocationFunction,
	pub pfnReallocation:  PFN_vkReallocationFunction,
	pub pfnFree:  PFN_vkFreeFunction,
	pub pfnInternalAllocation:  PFN_vkInternalAllocationNotification,
	pub pfnInternalFree:  PFN_vkInternalFreeNotification,

}
#[repr(C)]
pub struct VkDeviceQueueCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkDeviceQueueCreateFlags,
	pub queueFamilyIndex:  u32,
	pub queueCount:  u32,
	pub pQueuePriorities: *const f32,

}
#[repr(C)]
pub struct VkDeviceCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkDeviceCreateFlags,
	pub queueCreateInfoCount:  u32,
	pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
	pub enabledLayerCount:  u32,
	pub ppEnabledLayerNames: *const u8,
	pub enabledExtensionCount:  u32,
	pub ppEnabledExtensionNames: *const u8,
	pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,

}
#[repr(C)]
pub struct VkInstanceCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkInstanceCreateFlags,
	pub pApplicationInfo: *const VkApplicationInfo,
	pub enabledLayerCount:  u32,
	pub ppEnabledLayerNames: *const u8,
	pub enabledExtensionCount:  u32,
	pub ppEnabledExtensionNames: *const u8,

}
#[repr(C)]
pub struct VkQueueFamilyProperties {
	pub queueFlags:  VkQueueFlags,
	pub queueCount:  u32,
	pub timestampValidBits:  u32,
	pub minImageTransferGranularity:  VkExtent3D,

}
#[repr(C)]
pub struct VkPhysicalDeviceMemoryProperties {
	pub memoryTypeCount:  u32,
	pub memoryTypes: [ VkMemoryType; VK_MAX_MEMORY_TYPES],
	pub memoryHeapCount:  u32,
	pub memoryHeaps: [ VkMemoryHeap; VK_MAX_MEMORY_HEAPS],

}
#[repr(C)]
pub struct VkMemoryAllocateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub allocationSize:  VkDeviceSize,
	pub memoryTypeIndex:  u32,

}
#[repr(C)]
pub struct VkMemoryRequirements {
	pub size:  VkDeviceSize,
	pub alignment:  VkDeviceSize,
	pub memoryTypeBits:  u32,

}
#[repr(C)]
pub struct VkSparseImageFormatProperties {
	pub aspectMask:  VkImageAspectFlags,
	pub imageGranularity:  VkExtent3D,
	pub flags:  VkSparseImageFormatFlags,

}
#[repr(C)]
pub struct VkSparseImageMemoryRequirements {
	pub formatProperties:  VkSparseImageFormatProperties,
	pub imageMipTailFirstLod:  u32,
	pub imageMipTailSize:  VkDeviceSize,
	pub imageMipTailOffset:  VkDeviceSize,
	pub imageMipTailStride:  VkDeviceSize,

}
#[repr(C)]
pub struct VkMemoryType {
	pub propertyFlags:  VkMemoryPropertyFlags,
	pub heapIndex:  u32,

}
#[repr(C)]
pub struct VkMemoryHeap {
	pub size:  VkDeviceSize,
	pub flags:  VkMemoryHeapFlags,

}
#[repr(C)]
pub struct VkMappedMemoryRange {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub memory:  VkDeviceMemory,
	pub offset:  VkDeviceSize,
	pub size:  VkDeviceSize,

}
#[repr(C)]
pub struct VkFormatProperties {
	pub linearTilingFeatures:  VkFormatFeatureFlags,
	pub optimalTilingFeatures:  VkFormatFeatureFlags,
	pub bufferFeatures:  VkFormatFeatureFlags,

}
#[repr(C)]
pub struct VkImageFormatProperties {
	pub maxExtent:  VkExtent3D,
	pub maxMipLevels:  u32,
	pub maxArrayLayers:  u32,
	pub sampleCounts:  VkSampleCountFlags,
	pub maxResourceSize:  VkDeviceSize,

}
#[repr(C)]
pub struct VkDescriptorBufferInfo {
	pub buffer:  VkBuffer,
	pub offset:  VkDeviceSize,
	pub range:  VkDeviceSize,

}
#[repr(C)]
pub struct VkDescriptorImageInfo {
	pub sampler:  VkSampler,
	pub imageView:  VkImageView,
	pub imageLayout:  VkImageLayout,

}
#[repr(C)]
pub struct VkWriteDescriptorSet {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub dstSet:  VkDescriptorSet,
	pub dstBinding:  u32,
	pub dstArrayElement:  u32,
	pub descriptorCount:  u32,
	pub descriptorType:  VkDescriptorType,
	pub pImageInfo: *const VkDescriptorImageInfo,
	pub pBufferInfo: *const VkDescriptorBufferInfo,
	pub pTexelBufferView: *const VkBufferView,

}
#[repr(C)]
pub struct VkCopyDescriptorSet {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub srcSet:  VkDescriptorSet,
	pub srcBinding:  u32,
	pub srcArrayElement:  u32,
	pub dstSet:  VkDescriptorSet,
	pub dstBinding:  u32,
	pub dstArrayElement:  u32,
	pub descriptorCount:  u32,

}
#[repr(C)]
pub struct VkBufferCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkBufferCreateFlags,
	pub size:  VkDeviceSize,
	pub usage:  VkBufferUsageFlags,
	pub sharingMode:  VkSharingMode,
	pub queueFamilyIndexCount:  u32,
	pub pQueueFamilyIndices: *const u32,

}
#[repr(C)]
pub struct VkBufferViewCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkBufferViewCreateFlags,
	pub buffer:  VkBuffer,
	pub format:  VkFormat,
	pub offset:  VkDeviceSize,
	pub range:  VkDeviceSize,

}
#[repr(C)]
pub struct VkImageSubresource {
	pub aspectMask:  VkImageAspectFlags,
	pub mipLevel:  u32,
	pub arrayLayer:  u32,

}
#[repr(C)]
pub struct VkImageSubresourceLayers {
	pub aspectMask:  VkImageAspectFlags,
	pub mipLevel:  u32,
	pub baseArrayLayer:  u32,
	pub layerCount:  u32,

}
#[repr(C)]
pub struct VkImageSubresourceRange {
	pub aspectMask:  VkImageAspectFlags,
	pub baseMipLevel:  u32,
	pub levelCount:  u32,
	pub baseArrayLayer:  u32,
	pub layerCount:  u32,

}
#[repr(C)]
pub struct VkMemoryBarrier {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask:  VkAccessFlags,
	pub dstAccessMask:  VkAccessFlags,

}
#[repr(C)]
pub struct VkBufferMemoryBarrier {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask:  VkAccessFlags,
	pub dstAccessMask:  VkAccessFlags,
	pub srcQueueFamilyIndex:  u32,
	pub dstQueueFamilyIndex:  u32,
	pub buffer:  VkBuffer,
	pub offset:  VkDeviceSize,
	pub size:  VkDeviceSize,

}
#[repr(C)]
pub struct VkImageMemoryBarrier {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub srcAccessMask:  VkAccessFlags,
	pub dstAccessMask:  VkAccessFlags,
	pub oldLayout:  VkImageLayout,
	pub newLayout:  VkImageLayout,
	pub srcQueueFamilyIndex:  u32,
	pub dstQueueFamilyIndex:  u32,
	pub image:  VkImage,
	pub subresourceRange:  VkImageSubresourceRange,

}
#[repr(C)]
pub struct VkImageCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkImageCreateFlags,
	pub imageType:  VkImageType,
	pub format:  VkFormat,
	pub extent:  VkExtent3D,
	pub mipLevels:  u32,
	pub arrayLayers:  u32,
	pub samples:  VkSampleCountFlagBits,
	pub tiling:  VkImageTiling,
	pub usage:  VkImageUsageFlags,
	pub sharingMode:  VkSharingMode,
	pub queueFamilyIndexCount:  u32,
	pub pQueueFamilyIndices: *const u32,
	pub initialLayout:  VkImageLayout,

}
#[repr(C)]
pub struct VkSubresourceLayout {
	pub offset:  VkDeviceSize,
	pub size:  VkDeviceSize,
	pub rowPitch:  VkDeviceSize,
	pub arrayPitch:  VkDeviceSize,
	pub depthPitch:  VkDeviceSize,

}
#[repr(C)]
pub struct VkImageViewCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkImageViewCreateFlags,
	pub image:  VkImage,
	pub viewType:  VkImageViewType,
	pub format:  VkFormat,
	pub components:  VkComponentMapping,
	pub subresourceRange:  VkImageSubresourceRange,

}
#[repr(C)]
pub struct VkBufferCopy {
	pub srcOffset:  VkDeviceSize,
	pub dstOffset:  VkDeviceSize,
	pub size:  VkDeviceSize,

}
#[repr(C)]
pub struct VkSparseMemoryBind {
	pub resourceOffset:  VkDeviceSize,
	pub size:  VkDeviceSize,
	pub memory:  VkDeviceMemory,
	pub memoryOffset:  VkDeviceSize,
	pub flags:  VkSparseMemoryBindFlags,

}
#[repr(C)]
pub struct VkSparseImageMemoryBind {
	pub subresource:  VkImageSubresource,
	pub offset:  VkOffset3D,
	pub extent:  VkExtent3D,
	pub memory:  VkDeviceMemory,
	pub memoryOffset:  VkDeviceSize,
	pub flags:  VkSparseMemoryBindFlags,

}
#[repr(C)]
pub struct VkSparseBufferMemoryBindInfo {
	pub buffer:  VkBuffer,
	pub bindCount:  u32,
	pub pBinds: *const VkSparseMemoryBind,

}
#[repr(C)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
	pub image:  VkImage,
	pub bindCount:  u32,
	pub pBinds: *const VkSparseMemoryBind,

}
#[repr(C)]
pub struct VkSparseImageMemoryBindInfo {
	pub image:  VkImage,
	pub bindCount:  u32,
	pub pBinds: *const VkSparseImageMemoryBind,

}
#[repr(C)]
pub struct VkBindSparseInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount:  u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub bufferBindCount:  u32,
	pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
	pub imageOpaqueBindCount:  u32,
	pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
	pub imageBindCount:  u32,
	pub pImageBinds: *const VkSparseImageMemoryBindInfo,
	pub signalSemaphoreCount:  u32,
	pub pSignalSemaphores: *const VkSemaphore,

}
#[repr(C)]
pub struct VkImageCopy {
	pub srcSubresource:  VkImageSubresourceLayers,
	pub srcOffset:  VkOffset3D,
	pub dstSubresource:  VkImageSubresourceLayers,
	pub dstOffset:  VkOffset3D,
	pub extent:  VkExtent3D,

}
#[repr(C)]
pub struct VkImageBlit {
	pub srcSubresource:  VkImageSubresourceLayers,
	pub srcOffsets: [ VkOffset3D; 2],
	pub dstSubresource:  VkImageSubresourceLayers,
	pub dstOffsets: [ VkOffset3D; 2],

}
#[repr(C)]
pub struct VkBufferImageCopy {
	pub bufferOffset:  VkDeviceSize,
	pub bufferRowLength:  u32,
	pub bufferImageHeight:  u32,
	pub imageSubresource:  VkImageSubresourceLayers,
	pub imageOffset:  VkOffset3D,
	pub imageExtent:  VkExtent3D,

}
#[repr(C)]
pub struct VkImageResolve {
	pub srcSubresource:  VkImageSubresourceLayers,
	pub srcOffset:  VkOffset3D,
	pub dstSubresource:  VkImageSubresourceLayers,
	pub dstOffset:  VkOffset3D,
	pub extent:  VkExtent3D,

}
#[repr(C)]
pub struct VkShaderModuleCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkShaderModuleCreateFlags,
	pub codeSize:  size_t,
	pub pCode: *const u32,

}
#[repr(C)]
pub struct VkDescriptorSetLayoutBinding {
	pub binding:  u32,
	pub descriptorType:  VkDescriptorType,
	pub descriptorCount:  u32,
	pub stageFlags:  VkShaderStageFlags,
	pub pImmutableSamplers: *const VkSampler,

}
#[repr(C)]
pub struct VkDescriptorSetLayoutCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkDescriptorSetLayoutCreateFlags,
	pub bindingCount:  u32,
	pub pBindings: *const VkDescriptorSetLayoutBinding,

}
#[repr(C)]
pub struct VkDescriptorPoolSize {
	pub _type:  VkDescriptorType,
	pub descriptorCount:  u32,

}
#[repr(C)]
pub struct VkDescriptorPoolCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkDescriptorPoolCreateFlags,
	pub maxSets:  u32,
	pub poolSizeCount:  u32,
	pub pPoolSizes: *const VkDescriptorPoolSize,

}
#[repr(C)]
pub struct VkDescriptorSetAllocateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub descriptorPool:  VkDescriptorPool,
	pub descriptorSetCount:  u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,

}
#[repr(C)]
pub struct VkSpecializationMapEntry {
	pub constantID:  u32,
	pub offset:  u32,
	pub size:  size_t,

}
#[repr(C)]
pub struct VkSpecializationInfo {
	pub mapEntryCount:  u32,
	pub pMapEntries: *const VkSpecializationMapEntry,
	pub dataSize:  size_t,
	pub pData: *const c_void,

}
#[repr(C)]
pub struct VkPipelineShaderStageCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineShaderStageCreateFlags,
	pub stage:  VkShaderStageFlagBits,
	pub module:  VkShaderModule,
	pub pName: *const u8,
	pub pSpecializationInfo: *const VkSpecializationInfo,

}
#[repr(C)]
pub struct VkComputePipelineCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineCreateFlags,
	pub stage:  VkPipelineShaderStageCreateInfo,
	pub layout:  VkPipelineLayout,
	pub basePipelineHandle:  VkPipeline,
	pub basePipelineIndex:  i32,

}
#[repr(C)]
pub struct VkVertexInputBindingDescription {
	pub binding:  u32,
	pub stride:  u32,
	pub inputRate:  VkVertexInputRate,

}
#[repr(C)]
pub struct VkVertexInputAttributeDescription {
	pub location:  u32,
	pub binding:  u32,
	pub format:  VkFormat,
	pub offset:  u32,

}
#[repr(C)]
pub struct VkPipelineVertexInputStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineVertexInputStateCreateFlags,
	pub vertexBindingDescriptionCount:  u32,
	pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
	pub vertexAttributeDescriptionCount:  u32,
	pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,

}
#[repr(C)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineInputAssemblyStateCreateFlags,
	pub topology:  VkPrimitiveTopology,
	pub primitiveRestartEnable:  bool,

}
#[repr(C)]
pub struct VkPipelineTessellationStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineTessellationStateCreateFlags,
	pub patchControlPoints:  u32,

}
#[repr(C)]
pub struct VkPipelineViewportStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineViewportStateCreateFlags,
	pub viewportCount:  u32,
	pub pViewports: *const VkViewport,
	pub scissorCount:  u32,
	pub pScissors: *const VkRect2D,

}
#[repr(C)]
pub struct VkPipelineRasterizationStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineRasterizationStateCreateFlags,
	pub depthClampEnable:  bool,
	pub rasterizerDiscardEnable:  bool,
	pub polygonMode:  VkPolygonMode,
	pub cullMode:  VkCullModeFlags,
	pub frontFace:  VkFrontFace,
	pub depthBiasEnable:  bool,
	pub depthBiasConstantFactor:  f32,
	pub depthBiasClamp:  f32,
	pub depthBiasSlopeFactor:  f32,
	pub lineWidth:  f32,

}
#[repr(C)]
pub struct VkPipelineMultisampleStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineMultisampleStateCreateFlags,
	pub rasterizationSamples:  VkSampleCountFlagBits,
	pub sampleShadingEnable:  bool,
	pub minSampleShading:  f32,
	pub pSampleMask: *const VkSampleMask,
	pub alphaToCoverageEnable:  bool,
	pub alphaToOneEnable:  bool,

}
#[repr(C)]
pub struct VkPipelineColorBlendAttachmentState {
	pub blendEnable:  bool,
	pub srcColorBlendFactor:  VkBlendFactor,
	pub dstColorBlendFactor:  VkBlendFactor,
	pub colorBlendOp:  VkBlendOp,
	pub srcAlphaBlendFactor:  VkBlendFactor,
	pub dstAlphaBlendFactor:  VkBlendFactor,
	pub alphaBlendOp:  VkBlendOp,
	pub colorWriteMask:  VkColorComponentFlags,

}
#[repr(C)]
pub struct VkPipelineColorBlendStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineColorBlendStateCreateFlags,
	pub logicOpEnable:  bool,
	pub logicOp:  VkLogicOp,
	pub attachmentCount:  u32,
	pub pAttachments: *const VkPipelineColorBlendAttachmentState,
	pub blendConstants: [ f32; 4],

}
#[repr(C)]
pub struct VkPipelineDynamicStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineDynamicStateCreateFlags,
	pub dynamicStateCount:  u32,
	pub pDynamicStates: *const VkDynamicState,

}
#[repr(C)]
pub struct VkStencilOpState {
	pub failOp:  VkStencilOp,
	pub passOp:  VkStencilOp,
	pub depthFailOp:  VkStencilOp,
	pub compareOp:  VkCompareOp,
	pub compareMask:  u32,
	pub writeMask:  u32,
	pub reference:  u32,

}
#[repr(C)]
pub struct VkPipelineDepthStencilStateCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineDepthStencilStateCreateFlags,
	pub depthTestEnable:  bool,
	pub depthWriteEnable:  bool,
	pub depthCompareOp:  VkCompareOp,
	pub depthBoundsTestEnable:  bool,
	pub stencilTestEnable:  bool,
	pub front:  VkStencilOpState,
	pub back:  VkStencilOpState,
	pub minDepthBounds:  f32,
	pub maxDepthBounds:  f32,

}
#[repr(C)]
pub struct VkGraphicsPipelineCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineCreateFlags,
	pub stageCount:  u32,
	pub pStages: *const VkPipelineShaderStageCreateInfo,
	pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
	pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
	pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
	pub pViewportState: *const VkPipelineViewportStateCreateInfo,
	pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
	pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
	pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
	pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
	pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
	pub layout:  VkPipelineLayout,
	pub renderPass:  VkRenderPass,
	pub subpass:  u32,
	pub basePipelineHandle:  VkPipeline,
	pub basePipelineIndex:  i32,

}
#[repr(C)]
pub struct VkPipelineCacheCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineCacheCreateFlags,
	pub initialDataSize:  size_t,
	pub pInitialData: *const c_void,

}
#[repr(C)]
pub struct VkPushConstantRange {
	pub stageFlags:  VkShaderStageFlags,
	pub offset:  u32,
	pub size:  u32,

}
#[repr(C)]
pub struct VkPipelineLayoutCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineLayoutCreateFlags,
	pub setLayoutCount:  u32,
	pub pSetLayouts: *const VkDescriptorSetLayout,
	pub pushConstantRangeCount:  u32,
	pub pPushConstantRanges: *const VkPushConstantRange,

}
#[repr(C)]
pub struct VkSamplerCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkSamplerCreateFlags,
	pub magFilter:  VkFilter,
	pub minFilter:  VkFilter,
	pub mipmapMode:  VkSamplerMipmapMode,
	pub addressModeU:  VkSamplerAddressMode,
	pub addressModeV:  VkSamplerAddressMode,
	pub addressModeW:  VkSamplerAddressMode,
	pub mipLodBias:  f32,
	pub anisotropyEnable:  bool,
	pub maxAnisotropy:  f32,
	pub compareEnable:  bool,
	pub compareOp:  VkCompareOp,
	pub minLod:  f32,
	pub maxLod:  f32,
	pub borderColor:  VkBorderColor,
	pub unnormalizedCoordinates:  bool,

}
#[repr(C)]
pub struct VkCommandPoolCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkCommandPoolCreateFlags,
	pub queueFamilyIndex:  u32,

}
#[repr(C)]
pub struct VkCommandBufferAllocateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub commandPool:  VkCommandPool,
	pub level:  VkCommandBufferLevel,
	pub commandBufferCount:  u32,

}
#[repr(C)]
pub struct VkCommandBufferInheritanceInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub renderPass:  VkRenderPass,
	pub subpass:  u32,
	pub framebuffer:  VkFramebuffer,
	pub occlusionQueryEnable:  bool,
	pub queryFlags:  VkQueryControlFlags,
	pub pipelineStatistics:  VkQueryPipelineStatisticFlags,

}
#[repr(C)]
pub struct VkCommandBufferBeginInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkCommandBufferUsageFlags,
	pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,

}
#[repr(C)]
pub struct VkRenderPassBeginInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub renderPass:  VkRenderPass,
	pub framebuffer:  VkFramebuffer,
	pub renderArea:  VkRect2D,
	pub clearValueCount:  u32,
	pub pClearValues: *const VkClearValue,

}
#[repr(C)]
pub struct VkClearDepthStencilValue {
	pub float32: [ f32; 4],
	pub int32: [ i32; 4],
	pub uint32: [ u32; 4],
	pub depth:  f32,
	pub stencil:  u32,

}
#[repr(C)]
pub struct VkClearAttachment {
	pub color:  VkClearColorValue,
	pub depthStencil:  VkClearDepthStencilValue,
	pub aspectMask:  VkImageAspectFlags,
	pub colorAttachment:  u32,
	pub clearValue:  VkClearValue,

}
#[repr(C)]
pub struct VkAttachmentDescription {
	pub flags:  VkAttachmentDescriptionFlags,
	pub format:  VkFormat,
	pub samples:  VkSampleCountFlagBits,
	pub loadOp:  VkAttachmentLoadOp,
	pub storeOp:  VkAttachmentStoreOp,
	pub stencilLoadOp:  VkAttachmentLoadOp,
	pub stencilStoreOp:  VkAttachmentStoreOp,
	pub initialLayout:  VkImageLayout,
	pub finalLayout:  VkImageLayout,

}
#[repr(C)]
pub struct VkAttachmentReference {
	pub attachment:  u32,
	pub layout:  VkImageLayout,

}
#[repr(C)]
pub struct VkSubpassDescription {
	pub flags:  VkSubpassDescriptionFlags,
	pub pipelineBindPoint:  VkPipelineBindPoint,
	pub inputAttachmentCount:  u32,
	pub pInputAttachments: *const VkAttachmentReference,
	pub colorAttachmentCount:  u32,
	pub pColorAttachments: *const VkAttachmentReference,
	pub pResolveAttachments: *const VkAttachmentReference,
	pub pDepthStencilAttachment: *const VkAttachmentReference,
	pub preserveAttachmentCount:  u32,
	pub pPreserveAttachments: *const u32,

}
#[repr(C)]
pub struct VkSubpassDependency {
	pub srcSubpass:  u32,
	pub dstSubpass:  u32,
	pub srcStageMask:  VkPipelineStageFlags,
	pub dstStageMask:  VkPipelineStageFlags,
	pub srcAccessMask:  VkAccessFlags,
	pub dstAccessMask:  VkAccessFlags,
	pub dependencyFlags:  VkDependencyFlags,

}
#[repr(C)]
pub struct VkRenderPassCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkRenderPassCreateFlags,
	pub attachmentCount:  u32,
	pub pAttachments: *const VkAttachmentDescription,
	pub subpassCount:  u32,
	pub pSubpasses: *const VkSubpassDescription,
	pub dependencyCount:  u32,
	pub pDependencies: *const VkSubpassDependency,

}
#[repr(C)]
pub struct VkEventCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkEventCreateFlags,

}
#[repr(C)]
pub struct VkFenceCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkFenceCreateFlags,

}
#[repr(C)]
pub struct VkPhysicalDeviceFeatures {
	pub robustBufferAccess:  bool,
	pub fullDrawIndexUint32:  bool,
	pub imageCubeArray:  bool,
	pub independentBlend:  bool,
	pub geometryShader:  bool,
	pub tessellationShader:  bool,
	pub sampleRateShading:  bool,
	pub dualSrcBlend:  bool,
	pub logicOp:  bool,
	pub multiDrawIndirect:  bool,
	pub drawIndirectFirstInstance:  bool,
	pub depthClamp:  bool,
	pub depthBiasClamp:  bool,
	pub fillModeNonSolid:  bool,
	pub depthBounds:  bool,
	pub wideLines:  bool,
	pub largePoints:  bool,
	pub alphaToOne:  bool,
	pub multiViewport:  bool,
	pub samplerAnisotropy:  bool,
	pub textureCompressionETC2:  bool,
	pub textureCompressionASTC_LDR:  bool,
	pub textureCompressionBC:  bool,
	pub occlusionQueryPrecise:  bool,
	pub pipelineStatisticsQuery:  bool,
	pub vertexPipelineStoresAndAtomics:  bool,
	pub fragmentStoresAndAtomics:  bool,
	pub shaderTessellationAndGeometryPointSize:  bool,
	pub shaderImageGatherExtended:  bool,
	pub shaderStorageImageExtendedFormats:  bool,
	pub shaderStorageImageMultisample:  bool,
	pub shaderStorageImageReadWithoutFormat:  bool,
	pub shaderStorageImageWriteWithoutFormat:  bool,
	pub shaderUniformBufferArrayDynamicIndexing:  bool,
	pub shaderSampledImageArrayDynamicIndexing:  bool,
	pub shaderStorageBufferArrayDynamicIndexing:  bool,
	pub shaderStorageImageArrayDynamicIndexing:  bool,
	pub shaderClipDistance:  bool,
	pub shaderCullDistance:  bool,
	pub shaderFloat64:  bool,
	pub shaderInt64:  bool,
	pub shaderInt16:  bool,
	pub shaderResourceResidency:  bool,
	pub shaderResourceMinLod:  bool,
	pub sparseBinding:  bool,
	pub sparseResidencyBuffer:  bool,
	pub sparseResidencyImage2D:  bool,
	pub sparseResidencyImage3D:  bool,
	pub sparseResidency2Samples:  bool,
	pub sparseResidency4Samples:  bool,
	pub sparseResidency8Samples:  bool,
	pub sparseResidency16Samples:  bool,
	pub sparseResidencyAliased:  bool,
	pub variableMultisampleRate:  bool,
	pub inheritedQueries:  bool,

}
#[repr(C)]
pub struct VkPhysicalDeviceSparseProperties {
	pub residencyStandard2DBlockShape:  bool,
	pub residencyStandard2DMultisampleBlockShape:  bool,
	pub residencyStandard3DBlockShape:  bool,
	pub residencyAlignedMipSize:  bool,
	pub residencyNonResidentStrict:  bool,

}
#[repr(C)]
pub struct VkPhysicalDeviceLimits {
	pub maxImageDimension1D:  u32,
	pub maxImageDimension2D:  u32,
	pub maxImageDimension3D:  u32,
	pub maxImageDimensionCube:  u32,
	pub maxImageArrayLayers:  u32,
	pub maxTexelBufferElements:  u32,
	pub maxUniformBufferRange:  u32,
	pub maxStorageBufferRange:  u32,
	pub maxPushConstantsSize:  u32,
	pub maxMemoryAllocationCount:  u32,
	pub maxSamplerAllocationCount:  u32,
	pub bufferImageGranularity:  VkDeviceSize,
	pub sparseAddressSpaceSize:  VkDeviceSize,
	pub maxBoundDescriptorSets:  u32,
	pub maxPerStageDescriptorSamplers:  u32,
	pub maxPerStageDescriptorUniformBuffers:  u32,
	pub maxPerStageDescriptorStorageBuffers:  u32,
	pub maxPerStageDescriptorSampledImages:  u32,
	pub maxPerStageDescriptorStorageImages:  u32,
	pub maxPerStageDescriptorInputAttachments:  u32,
	pub maxPerStageResources:  u32,
	pub maxDescriptorSetSamplers:  u32,
	pub maxDescriptorSetUniformBuffers:  u32,
	pub maxDescriptorSetUniformBuffersDynamic:  u32,
	pub maxDescriptorSetStorageBuffers:  u32,
	pub maxDescriptorSetStorageBuffersDynamic:  u32,
	pub maxDescriptorSetSampledImages:  u32,
	pub maxDescriptorSetStorageImages:  u32,
	pub maxDescriptorSetInputAttachments:  u32,
	pub maxVertexInputAttributes:  u32,
	pub maxVertexInputBindings:  u32,
	pub maxVertexInputAttributeOffset:  u32,
	pub maxVertexInputBindingStride:  u32,
	pub maxVertexOutputComponents:  u32,
	pub maxTessellationGenerationLevel:  u32,
	pub maxTessellationPatchSize:  u32,
	pub maxTessellationControlPerVertexInputComponents:  u32,
	pub maxTessellationControlPerVertexOutputComponents:  u32,
	pub maxTessellationControlPerPatchOutputComponents:  u32,
	pub maxTessellationControlTotalOutputComponents:  u32,
	pub maxTessellationEvaluationInputComponents:  u32,
	pub maxTessellationEvaluationOutputComponents:  u32,
	pub maxGeometryShaderInvocations:  u32,
	pub maxGeometryInputComponents:  u32,
	pub maxGeometryOutputComponents:  u32,
	pub maxGeometryOutputVertices:  u32,
	pub maxGeometryTotalOutputComponents:  u32,
	pub maxFragmentInputComponents:  u32,
	pub maxFragmentOutputAttachments:  u32,
	pub maxFragmentDualSrcAttachments:  u32,
	pub maxFragmentCombinedOutputResources:  u32,
	pub maxComputeSharedMemorySize:  u32,
	pub maxComputeWorkGroupCount: [ u32; 3],
	pub maxComputeWorkGroupInvocations:  u32,
	pub maxComputeWorkGroupSize: [ u32; 3],
	pub subPixelPrecisionBits:  u32,
	pub subTexelPrecisionBits:  u32,
	pub mipmapPrecisionBits:  u32,
	pub maxDrawIndexedIndexValue:  u32,
	pub maxDrawIndirectCount:  u32,
	pub maxSamplerLodBias:  f32,
	pub maxSamplerAnisotropy:  f32,
	pub maxViewports:  u32,
	pub maxViewportDimensions: [ u32; 2],
	pub viewportBoundsRange: [ f32; 2],
	pub viewportSubPixelBits:  u32,
	pub minMemoryMapAlignment:  size_t,
	pub minTexelBufferOffsetAlignment:  VkDeviceSize,
	pub minUniformBufferOffsetAlignment:  VkDeviceSize,
	pub minStorageBufferOffsetAlignment:  VkDeviceSize,
	pub minTexelOffset:  i32,
	pub maxTexelOffset:  u32,
	pub minTexelGatherOffset:  i32,
	pub maxTexelGatherOffset:  u32,
	pub minInterpolationOffset:  f32,
	pub maxInterpolationOffset:  f32,
	pub subPixelInterpolationOffsetBits:  u32,
	pub maxFramebufferWidth:  u32,
	pub maxFramebufferHeight:  u32,
	pub maxFramebufferLayers:  u32,
	pub framebufferColorSampleCounts:  VkSampleCountFlags,
	pub framebufferDepthSampleCounts:  VkSampleCountFlags,
	pub framebufferStencilSampleCounts:  VkSampleCountFlags,
	pub framebufferNoAttachmentsSampleCounts:  VkSampleCountFlags,
	pub maxColorAttachments:  u32,
	pub sampledImageColorSampleCounts:  VkSampleCountFlags,
	pub sampledImageIntegerSampleCounts:  VkSampleCountFlags,
	pub sampledImageDepthSampleCounts:  VkSampleCountFlags,
	pub sampledImageStencilSampleCounts:  VkSampleCountFlags,
	pub storageImageSampleCounts:  VkSampleCountFlags,
	pub maxSampleMaskWords:  u32,
	pub timestampComputeAndGraphics:  bool,
	pub timestampPeriod:  f32,
	pub maxClipDistances:  u32,
	pub maxCullDistances:  u32,
	pub maxCombinedClipAndCullDistances:  u32,
	pub discreteQueuePriorities:  u32,
	pub pointSizeRange: [ f32; 2],
	pub lineWidthRange: [ f32; 2],
	pub pointSizeGranularity:  f32,
	pub lineWidthGranularity:  f32,
	pub strictLines:  bool,
	pub standardSampleLocations:  bool,
	pub optimalBufferCopyOffsetAlignment:  VkDeviceSize,
	pub optimalBufferCopyRowPitchAlignment:  VkDeviceSize,
	pub nonCoherentAtomSize:  VkDeviceSize,

}
#[repr(C)]
pub struct VkSemaphoreCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkSemaphoreCreateFlags,

}
#[repr(C)]
pub struct VkQueryPoolCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkQueryPoolCreateFlags,
	pub queryType:  VkQueryType,
	pub queryCount:  u32,
	pub pipelineStatistics:  VkQueryPipelineStatisticFlags,

}
#[repr(C)]
pub struct VkFramebufferCreateInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkFramebufferCreateFlags,
	pub renderPass:  VkRenderPass,
	pub attachmentCount:  u32,
	pub pAttachments: *const VkImageView,
	pub width:  u32,
	pub height:  u32,
	pub layers:  u32,

}
#[repr(C)]
pub struct VkDrawIndirectCommand {
	pub vertexCount:  u32,
	pub instanceCount:  u32,
	pub firstVertex:  u32,
	pub firstInstance:  u32,

}
#[repr(C)]
pub struct VkDrawIndexedIndirectCommand {
	pub indexCount:  u32,
	pub instanceCount:  u32,
	pub firstIndex:  u32,
	pub vertexOffset:  i32,
	pub firstInstance:  u32,

}
#[repr(C)]
pub struct VkDispatchIndirectCommand {
	pub x:  u32,
	pub y:  u32,
	pub z:  u32,

}
#[repr(C)]
pub struct VkSubmitInfo {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount:  u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub pWaitDstStageMask: *const VkPipelineStageFlags,
	pub commandBufferCount:  u32,
	pub pCommandBuffers: *const VkCommandBuffer,
	pub signalSemaphoreCount:  u32,
	pub pSignalSemaphores: *const VkSemaphore,

}
#[repr(C)]
pub struct VkDisplayPropertiesKHR {
	pub display:  VkDisplayKHR,
	pub displayName: *const u8,
	pub physicalDimensions:  VkExtent2D,
	pub physicalResolution:  VkExtent2D,
	pub supportedTransforms:  VkSurfaceTransformFlagsKHR,
	pub planeReorderPossible:  bool,
	pub persistentContent:  bool,

}
#[repr(C)]
pub struct VkDisplayPlanePropertiesKHR {
	pub currentDisplay:  VkDisplayKHR,
	pub currentStackIndex:  u32,

}
#[repr(C)]
pub struct VkDisplayModeParametersKHR {
	pub visibleRegion:  VkExtent2D,
	pub refreshRate:  u32,

}
#[repr(C)]
pub struct VkDisplayModePropertiesKHR {
	pub displayMode:  VkDisplayModeKHR,
	pub parameters:  VkDisplayModeParametersKHR,

}
#[repr(C)]
pub struct VkDisplayModeCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkDisplayModeCreateFlagsKHR,
	pub parameters:  VkDisplayModeParametersKHR,

}
#[repr(C)]
pub struct VkDisplayPlaneCapabilitiesKHR {
	pub supportedAlpha:  VkDisplayPlaneAlphaFlagsKHR,
	pub minSrcPosition:  VkOffset2D,
	pub maxSrcPosition:  VkOffset2D,
	pub minSrcExtent:  VkExtent2D,
	pub maxSrcExtent:  VkExtent2D,
	pub minDstPosition:  VkOffset2D,
	pub maxDstPosition:  VkOffset2D,
	pub minDstExtent:  VkExtent2D,
	pub maxDstExtent:  VkExtent2D,

}
#[repr(C)]
pub struct VkDisplaySurfaceCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkDisplaySurfaceCreateFlagsKHR,
	pub displayMode:  VkDisplayModeKHR,
	pub planeIndex:  u32,
	pub planeStackIndex:  u32,
	pub transform:  VkSurfaceTransformFlagBitsKHR,
	pub globalAlpha:  f32,
	pub alphaMode:  VkDisplayPlaneAlphaFlagBitsKHR,
	pub imageExtent:  VkExtent2D,

}
#[repr(C)]
pub struct VkDisplayPresentInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub srcRect:  VkRect2D,
	pub dstRect:  VkRect2D,
	pub persistent:  bool,

}
#[repr(C)]
pub struct VkSurfaceCapabilitiesKHR {
	pub minImageCount:  u32,
	pub maxImageCount:  u32,
	pub currentExtent:  VkExtent2D,
	pub minImageExtent:  VkExtent2D,
	pub maxImageExtent:  VkExtent2D,
	pub maxImageArrayLayers:  u32,
	pub supportedTransforms:  VkSurfaceTransformFlagsKHR,
	pub currentTransform:  VkSurfaceTransformFlagBitsKHR,
	pub supportedCompositeAlpha:  VkCompositeAlphaFlagsKHR,
	pub supportedUsageFlags:  VkImageUsageFlags,

}
#[repr(C)]
pub struct VkAndroidSurfaceCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkAndroidSurfaceCreateFlagsKHR,
	pub window: *mut ANativeWindow,

}
#[repr(C)]
pub struct VkMirSurfaceCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkMirSurfaceCreateFlagsKHR,
	pub connection: *mut MirConnection,
	pub mirSurface: *mut MirSurface,

}
#[repr(C)]
pub struct VkViSurfaceCreateInfoNN {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkViSurfaceCreateFlagsNN,
	pub window: *mut c_void,

}
#[repr(C)]
pub struct VkWaylandSurfaceCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkWaylandSurfaceCreateFlagsKHR,
	pub display: *mut wl_display,
	pub surface: *mut wl_surface,

}
#[repr(C)]
pub struct VkWin32SurfaceCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkWin32SurfaceCreateFlagsKHR,
	pub hinstance:  HINSTANCE,
	pub hwnd:  HWND,

}
#[repr(C)]
pub struct VkXlibSurfaceCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkXlibSurfaceCreateFlagsKHR,
	pub dpy: *mut Display,
	pub window:  Window,

}
#[repr(C)]
pub struct VkXcbSurfaceCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkXcbSurfaceCreateFlagsKHR,
	pub connection: *mut xcb_connection_t,
	pub window:  xcb_window_t,

}
#[repr(C)]
pub struct VkSurfaceFormatKHR {
	pub format:  VkFormat,
	pub colorSpace:  VkColorSpaceKHR,

}
#[repr(C)]
pub struct VkSwapchainCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkSwapchainCreateFlagsKHR,
	pub surface:  VkSurfaceKHR,
	pub minImageCount:  u32,
	pub imageFormat:  VkFormat,
	pub imageColorSpace:  VkColorSpaceKHR,
	pub imageExtent:  VkExtent2D,
	pub imageArrayLayers:  u32,
	pub imageUsage:  VkImageUsageFlags,
	pub imageSharingMode:  VkSharingMode,
	pub queueFamilyIndexCount:  u32,
	pub pQueueFamilyIndices: *const u32,
	pub preTransform:  VkSurfaceTransformFlagBitsKHR,
	pub compositeAlpha:  VkCompositeAlphaFlagBitsKHR,
	pub presentMode:  VkPresentModeKHR,
	pub clipped:  bool,
	pub oldSwapchain:  VkSwapchainKHR,

}
#[repr(C)]
pub struct VkPresentInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount:  u32,
	pub pWaitSemaphores: *const VkSemaphore,
	pub swapchainCount:  u32,
	pub pSwapchains: *const VkSwapchainKHR,
	pub pImageIndices: *const u32,
	pub pResults: *mut VkResult,

}
#[repr(C)]
pub struct VkDebugReportCallbackCreateInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkDebugReportFlagsEXT,
	pub pfnCallback:  PFN_vkDebugReportCallbackEXT,
	pub pUserData: *mut c_void,

}
#[repr(C)]
pub struct VkValidationFlagsEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub disabledValidationCheckCount:  u32,
	pub pDisabledValidationChecks: *mut VkValidationCheckEXT,

}
#[repr(C)]
pub struct VkPipelineRasterizationStateRasterizationOrderAMD {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub rasterizationOrder:  VkRasterizationOrderAMD,

}
#[repr(C)]
pub struct VkDebugMarkerObjectNameInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub objectType:  VkDebugReportObjectTypeEXT,
	pub object:  u64,
	pub pObjectName: *const u8,

}
#[repr(C)]
pub struct VkDebugMarkerObjectTagInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub objectType:  VkDebugReportObjectTypeEXT,
	pub object:  u64,
	pub tagName:  u64,
	pub tagSize:  size_t,
	pub pTag: *const c_void,

}
#[repr(C)]
pub struct VkDebugMarkerMarkerInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub pMarkerName: *const u8,
	pub color: [ f32; 4],

}
#[repr(C)]
pub struct VkDedicatedAllocationImageCreateInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub dedicatedAllocation:  bool,

}
#[repr(C)]
pub struct VkDedicatedAllocationBufferCreateInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub dedicatedAllocation:  bool,

}
#[repr(C)]
pub struct VkDedicatedAllocationMemoryAllocateInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub image:  VkImage,
	pub buffer:  VkBuffer,

}
#[repr(C)]
pub struct VkExternalImageFormatPropertiesNV {
	pub imageFormatProperties:  VkImageFormatProperties,
	pub externalMemoryFeatures:  VkExternalMemoryFeatureFlagsNV,
	pub exportFromImportedHandleTypes:  VkExternalMemoryHandleTypeFlagsNV,
	pub compatibleHandleTypes:  VkExternalMemoryHandleTypeFlagsNV,

}
#[repr(C)]
pub struct VkExternalMemoryImageCreateInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes:  VkExternalMemoryHandleTypeFlagsNV,

}
#[repr(C)]
pub struct VkExportMemoryAllocateInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes:  VkExternalMemoryHandleTypeFlagsNV,

}
#[repr(C)]
pub struct VkImportMemoryWin32HandleInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleType:  VkExternalMemoryHandleTypeFlagsNV,
	pub handle:  HANDLE,

}
#[repr(C)]
pub struct VkExportMemoryWin32HandleInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub pAttributes: *const SECURITY_ATTRIBUTES,
	pub dwAccess:  DWORD,

}
#[repr(C)]
pub struct VkWin32KeyedMutexAcquireReleaseInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub acquireCount:  u32,
	pub pAcquireSyncs: *const VkDeviceMemory,
	pub pAcquireKeys: *const u64,
	pub pAcquireTimeoutMilliseconds: *const u32,
	pub releaseCount:  u32,
	pub pReleaseSyncs: *const VkDeviceMemory,
	pub pReleaseKeys: *const u64,

}
#[repr(C)]
pub struct VkDeviceGeneratedCommandsFeaturesNVX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub computeBindingPointSupport:  bool,

}
#[repr(C)]
pub struct VkDeviceGeneratedCommandsLimitsNVX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub maxIndirectCommandsLayoutTokenCount:  u32,
	pub maxObjectEntryCounts:  u32,
	pub minSequenceCountBufferOffsetAlignment:  u32,
	pub minSequenceIndexBufferOffsetAlignment:  u32,
	pub minCommandsTokenBufferOffsetAlignment:  u32,

}
#[repr(C)]
pub struct VkIndirectCommandsTokenNVX {
	pub tokenType:  VkIndirectCommandsTokenTypeNVX,
	pub buffer:  VkBuffer,
	pub offset:  VkDeviceSize,

}
#[repr(C)]
pub struct VkIndirectCommandsLayoutTokenNVX {
	pub tokenType:  VkIndirectCommandsTokenTypeNVX,
	pub bindingUnit:  u32,
	pub dynamicCount:  u32,
	pub divisor:  u32,

}
#[repr(C)]
pub struct VkIndirectCommandsLayoutCreateInfoNVX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub pipelineBindPoint:  VkPipelineBindPoint,
	pub flags:  VkIndirectCommandsLayoutUsageFlagsNVX,
	pub tokenCount:  u32,
	pub pTokens: *const VkIndirectCommandsLayoutTokenNVX,

}
#[repr(C)]
pub struct VkCmdProcessCommandsInfoNVX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub objectTable:  VkObjectTableNVX,
	pub indirectCommandsLayout:  VkIndirectCommandsLayoutNVX,
	pub indirectCommandsTokenCount:  u32,
	pub pIndirectCommandsTokens: *const VkIndirectCommandsTokenNVX,
	pub maxSequencesCount:  u32,
	pub targetCommandBuffer:  VkCommandBuffer,
	pub sequencesCountBuffer:  VkBuffer,
	pub sequencesCountOffset:  VkDeviceSize,
	pub sequencesIndexBuffer:  VkBuffer,
	pub sequencesIndexOffset:  VkDeviceSize,

}
#[repr(C)]
pub struct VkCmdReserveSpaceForCommandsInfoNVX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub objectTable:  VkObjectTableNVX,
	pub indirectCommandsLayout:  VkIndirectCommandsLayoutNVX,
	pub maxSequencesCount:  u32,

}
#[repr(C)]
pub struct VkObjectTableCreateInfoNVX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub objectCount:  u32,
	pub pObjectEntryTypes: *const VkObjectEntryTypeNVX,
	pub pObjectEntryCounts: *const u32,
	pub pObjectEntryUsageFlags: *const VkObjectEntryUsageFlagsNVX,
	pub maxUniformBuffersPerDescriptor:  u32,
	pub maxStorageBuffersPerDescriptor:  u32,
	pub maxStorageImagesPerDescriptor:  u32,
	pub maxSampledImagesPerDescriptor:  u32,
	pub maxPipelineLayouts:  u32,

}
#[repr(C)]
pub struct VkObjectTableEntryNVX {
	pub _type:  VkObjectEntryTypeNVX,
	pub flags:  VkObjectEntryUsageFlagsNVX,

}
#[repr(C)]
pub struct VkObjectTablePipelineEntryNVX {
	pub _type:  VkObjectEntryTypeNVX,
	pub flags:  VkObjectEntryUsageFlagsNVX,
	pub pipeline:  VkPipeline,

}
#[repr(C)]
pub struct VkObjectTableDescriptorSetEntryNVX {
	pub _type:  VkObjectEntryTypeNVX,
	pub flags:  VkObjectEntryUsageFlagsNVX,
	pub pipelineLayout:  VkPipelineLayout,
	pub descriptorSet:  VkDescriptorSet,

}
#[repr(C)]
pub struct VkObjectTableVertexBufferEntryNVX {
	pub _type:  VkObjectEntryTypeNVX,
	pub flags:  VkObjectEntryUsageFlagsNVX,
	pub buffer:  VkBuffer,

}
#[repr(C)]
pub struct VkObjectTableIndexBufferEntryNVX {
	pub _type:  VkObjectEntryTypeNVX,
	pub flags:  VkObjectEntryUsageFlagsNVX,
	pub buffer:  VkBuffer,
	pub indexType:  VkIndexType,

}
#[repr(C)]
pub struct VkObjectTablePushConstantEntryNVX {
	pub _type:  VkObjectEntryTypeNVX,
	pub flags:  VkObjectEntryUsageFlagsNVX,
	pub pipelineLayout:  VkPipelineLayout,
	pub stageFlags:  VkShaderStageFlags,

}
#[repr(C)]
pub struct VkPhysicalDeviceFeatures2KHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub features:  VkPhysicalDeviceFeatures,

}
#[repr(C)]
pub struct VkPhysicalDeviceProperties2KHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub properties:  VkPhysicalDeviceProperties,

}
#[repr(C)]
pub struct VkFormatProperties2KHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub formatProperties:  VkFormatProperties,

}
#[repr(C)]
pub struct VkImageFormatProperties2KHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub imageFormatProperties:  VkImageFormatProperties,

}
#[repr(C)]
pub struct VkPhysicalDeviceImageFormatInfo2KHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub format:  VkFormat,
	pub _type:  VkImageType,
	pub tiling:  VkImageTiling,
	pub usage:  VkImageUsageFlags,
	pub flags:  VkImageCreateFlags,

}
#[repr(C)]
pub struct VkQueueFamilyProperties2KHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub queueFamilyProperties:  VkQueueFamilyProperties,

}
#[repr(C)]
pub struct VkPhysicalDeviceMemoryProperties2KHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub memoryProperties:  VkPhysicalDeviceMemoryProperties,

}
#[repr(C)]
pub struct VkSparseImageFormatProperties2KHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub properties:  VkSparseImageFormatProperties,

}
#[repr(C)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2KHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub format:  VkFormat,
	pub _type:  VkImageType,
	pub samples:  VkSampleCountFlagBits,
	pub usage:  VkImageUsageFlags,
	pub tiling:  VkImageTiling,

}
#[repr(C)]
pub struct VkPhysicalDevicePushDescriptorPropertiesKHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub maxPushDescriptors:  u32,

}
#[repr(C)]
pub struct VkPresentRegionsKHR {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount:  u32,
	pub pRegions: *const VkPresentRegionKHR,

}
#[repr(C)]
pub struct VkPresentRegionKHR {
	pub rectangleCount:  u32,
	pub pRectangles: *const VkRectLayerKHR,

}
#[repr(C)]
pub struct VkRectLayerKHR {
	pub offset:  VkOffset2D,
	pub extent:  VkExtent2D,
	pub layer:  u32,

}
#[repr(C)]
pub struct VkExternalMemoryPropertiesKHX {
	pub externalMemoryFeatures:  VkExternalMemoryFeatureFlagsKHX,
	pub exportFromImportedHandleTypes:  VkExternalMemoryHandleTypeFlagsKHX,
	pub compatibleHandleTypes:  VkExternalMemoryHandleTypeFlagsKHX,

}
#[repr(C)]
pub struct VkPhysicalDeviceExternalImageFormatInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleType:  VkExternalMemoryHandleTypeFlagBitsKHX,

}
#[repr(C)]
pub struct VkExternalImageFormatPropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryProperties:  VkExternalMemoryPropertiesKHX,

}
#[repr(C)]
pub struct VkPhysicalDeviceExternalBufferInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkBufferCreateFlags,
	pub usage:  VkBufferUsageFlags,
	pub handleType:  VkExternalMemoryHandleTypeFlagBitsKHX,

}
#[repr(C)]
pub struct VkExternalBufferPropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub externalMemoryProperties:  VkExternalMemoryPropertiesKHX,

}
#[repr(C)]
pub struct VkPhysicalDeviceIDPropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub deviceUUID: [ u8; VK_UUID_SIZE],
	pub driverUUID: [ u8; VK_UUID_SIZE],
	pub deviceLUID: [ u8; VK_LUID_SIZE_KHX],
	pub deviceLUIDValid:  bool,

}
#[repr(C)]
pub struct VkExternalMemoryImageCreateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes:  VkExternalMemoryHandleTypeFlagsKHX,

}
#[repr(C)]
pub struct VkExternalMemoryBufferCreateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes:  VkExternalMemoryHandleTypeFlagsKHX,

}
#[repr(C)]
pub struct VkExportMemoryAllocateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes:  VkExternalMemoryHandleTypeFlagsKHX,

}
#[repr(C)]
pub struct VkImportMemoryWin32HandleInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleType:  VkExternalMemoryHandleTypeFlagBitsKHX,
	pub handle:  HANDLE,

}
#[repr(C)]
pub struct VkExportMemoryWin32HandleInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub pAttributes: *const SECURITY_ATTRIBUTES,
	pub dwAccess:  DWORD,
	pub name:  LPCWSTR,

}
#[repr(C)]
pub struct VkMemoryWin32HandlePropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub memoryTypeBits:  u32,

}
#[repr(C)]
pub struct VkImportMemoryFdInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleType:  VkExternalMemoryHandleTypeFlagBitsKHX,
	pub fd:  i32,

}
#[repr(C)]
pub struct VkMemoryFdPropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub memoryTypeBits:  u32,

}
#[repr(C)]
pub struct VkWin32KeyedMutexAcquireReleaseInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub acquireCount:  u32,
	pub pAcquireSyncs: *const VkDeviceMemory,
	pub pAcquireKeys: *const u64,
	pub pAcquireTimeouts: *const u32,
	pub releaseCount:  u32,
	pub pReleaseSyncs: *const VkDeviceMemory,
	pub pReleaseKeys: *const u64,

}
#[repr(C)]
pub struct VkPhysicalDeviceExternalSemaphoreInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleType:  VkExternalSemaphoreHandleTypeFlagBitsKHX,

}
#[repr(C)]
pub struct VkExternalSemaphorePropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub exportFromImportedHandleTypes:  VkExternalSemaphoreHandleTypeFlagsKHX,
	pub compatibleHandleTypes:  VkExternalSemaphoreHandleTypeFlagsKHX,
	pub externalSemaphoreFeatures:  VkExternalSemaphoreFeatureFlagsKHX,

}
#[repr(C)]
pub struct VkExportSemaphoreCreateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub handleTypes:  VkExternalSemaphoreHandleTypeFlagsKHX,

}
#[repr(C)]
pub struct VkImportSemaphoreWin32HandleInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub semaphore:  VkSemaphore,
	pub handleType:  VkExternalSemaphoreHandleTypeFlagsKHX,
	pub handle:  HANDLE,

}
#[repr(C)]
pub struct VkExportSemaphoreWin32HandleInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub pAttributes: *const SECURITY_ATTRIBUTES,
	pub dwAccess:  DWORD,
	pub name:  LPCWSTR,

}
#[repr(C)]
pub struct VkD3D12FenceSubmitInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreValuesCount:  u32,
	pub pWaitSemaphoreValues: *const u64,
	pub signalSemaphoreValuesCount:  u32,
	pub pSignalSemaphoreValues: *const u64,

}
#[repr(C)]
pub struct VkImportSemaphoreFdInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub semaphore:  VkSemaphore,
	pub handleType:  VkExternalSemaphoreHandleTypeFlagBitsKHX,
	pub fd:  i32,

}
#[repr(C)]
pub struct VkPhysicalDeviceMultiviewFeaturesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub multiview:  bool,
	pub multiviewGeometryShader:  bool,
	pub multiviewTessellationShader:  bool,

}
#[repr(C)]
pub struct VkPhysicalDeviceMultiviewPropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub maxMultiviewViewCount:  u32,
	pub maxMultiviewInstanceIndex:  u32,

}
#[repr(C)]
pub struct VkRenderPassMultiviewCreateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub subpassCount:  u32,
	pub pViewMasks: *const u32,
	pub dependencyCount:  u32,
	pub pViewOffsets: *const i32,
	pub correlationMaskCount:  u32,
	pub pCorrelationMasks: *const u32,

}
#[repr(C)]
pub struct VkSurfaceCapabilities2EXT {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub minImageCount:  u32,
	pub maxImageCount:  u32,
	pub currentExtent:  VkExtent2D,
	pub minImageExtent:  VkExtent2D,
	pub maxImageExtent:  VkExtent2D,
	pub maxImageArrayLayers:  u32,
	pub supportedTransforms:  VkSurfaceTransformFlagsKHR,
	pub currentTransform:  VkSurfaceTransformFlagBitsKHR,
	pub supportedCompositeAlpha:  VkCompositeAlphaFlagsKHR,
	pub supportedUsageFlags:  VkImageUsageFlags,
	pub supportedSurfaceCounters:  VkSurfaceCounterFlagsEXT,

}
#[repr(C)]
pub struct VkDisplayPowerInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub powerState:  VkDisplayPowerStateEXT,

}
#[repr(C)]
pub struct VkDeviceEventInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub deviceEvent:  VkDeviceEventTypeEXT,

}
#[repr(C)]
pub struct VkDisplayEventInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub displayEvent:  VkDisplayEventTypeEXT,

}
#[repr(C)]
pub struct VkSwapchainCounterCreateInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub surfaceCounters:  VkSurfaceCounterFlagsEXT,

}
#[repr(C)]
pub struct VkPhysicalDeviceGroupPropertiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub physicalDeviceCount:  u32,
	pub physicalDevices: [ VkPhysicalDevice; VK_MAX_DEVICE_GROUP_SIZE_KHX],
	pub subsetAllocation:  bool,

}
#[repr(C)]
pub struct VkMemoryAllocateFlagsInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkMemoryAllocateFlagsKHX,
	pub deviceMask:  u32,

}
#[repr(C)]
pub struct VkBindBufferMemoryInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub buffer:  VkBuffer,
	pub memory:  VkDeviceMemory,
	pub memoryOffset:  VkDeviceSize,
	pub deviceIndexCount:  u32,
	pub pDeviceIndices: *const u32,

}
#[repr(C)]
pub struct VkBindImageMemoryInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub image:  VkImage,
	pub memory:  VkDeviceMemory,
	pub memoryOffset:  VkDeviceSize,
	pub deviceIndexCount:  u32,
	pub pDeviceIndices: *const u32,
	pub SFRRectCount:  u32,
	pub pSFRRects: *const VkRect2D,

}
#[repr(C)]
pub struct VkDeviceGroupRenderPassBeginInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub deviceMask:  u32,
	pub deviceRenderAreaCount:  u32,
	pub pDeviceRenderAreas: *const VkRect2D,

}
#[repr(C)]
pub struct VkDeviceGroupCommandBufferBeginInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub deviceMask:  u32,

}
#[repr(C)]
pub struct VkDeviceGroupSubmitInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub waitSemaphoreCount:  u32,
	pub pWaitSemaphoreDeviceIndices: *const u32,
	pub commandBufferCount:  u32,
	pub pCommandBufferDeviceMasks: *const u32,
	pub signalSemaphoreCount:  u32,
	pub pSignalSemaphoreDeviceIndices: *const u32,

}
#[repr(C)]
pub struct VkDeviceGroupBindSparseInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub resourceDeviceIndex:  u32,
	pub memoryDeviceIndex:  u32,

}
#[repr(C)]
pub struct VkDeviceGroupPresentCapabilitiesKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub presentMask: [ u32; VK_MAX_DEVICE_GROUP_SIZE_KHX],
	pub modes:  VkDeviceGroupPresentModeFlagsKHX,

}
#[repr(C)]
pub struct VkImageSwapchainCreateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub swapchain:  VkSwapchainKHR,

}
#[repr(C)]
pub struct VkBindImageMemorySwapchainInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub swapchain:  VkSwapchainKHR,
	pub imageIndex:  u32,

}
#[repr(C)]
pub struct VkAcquireNextImageInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub swapchain:  VkSwapchainKHR,
	pub timeout:  u64,
	pub semaphore:  VkSemaphore,
	pub fence:  VkFence,
	pub deviceMask:  u32,

}
#[repr(C)]
pub struct VkDeviceGroupPresentInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount:  u32,
	pub pDeviceMasks: *const u32,
	pub mode:  VkDeviceGroupPresentModeFlagBitsKHX,

}
#[repr(C)]
pub struct VkDeviceGroupDeviceCreateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub physicalDeviceCount:  u32,
	pub pPhysicalDevices: *const VkPhysicalDevice,

}
#[repr(C)]
pub struct VkDeviceGroupSwapchainCreateInfoKHX {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub modes:  VkDeviceGroupPresentModeFlagsKHX,

}
#[repr(C)]
pub struct VkDescriptorUpdateTemplateEntryKHR {
	pub dstBinding:  u32,
	pub dstArrayElement:  u32,
	pub descriptorCount:  u32,
	pub descriptorType:  VkDescriptorType,
	pub offset:  size_t,
	pub stride:  size_t,

}
#[repr(C)]
pub struct VkDescriptorUpdateTemplateCreateInfoKHR {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub flags:  VkDescriptorUpdateTemplateCreateFlagsKHR,
	pub descriptorUpdateEntryCount:  u32,
	pub pDescriptorUpdateEntries: *const VkDescriptorUpdateTemplateEntryKHR,
	pub templateType:  VkDescriptorUpdateTemplateTypeKHR,
	pub descriptorSetLayout:  VkDescriptorSetLayout,
	pub pipelineBindPoint:  VkPipelineBindPoint,
	pub pipelineLayout:  VkPipelineLayout,
	pub set:  u32,

}
#[repr(C)]
pub struct VkXYColorEXT {
	pub x:  f32,
	pub y:  f32,

}
#[repr(C)]
pub struct VkHdrMetadataEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub displayPrimaryRed:  VkXYColorEXT,
	pub displayPrimaryGreen:  VkXYColorEXT,
	pub displayPrimaryBlue:  VkXYColorEXT,
	pub whitePoint:  VkXYColorEXT,
	pub maxLuminance:  f32,
	pub minLuminance:  f32,
	pub maxContentLightLevel:  f32,
	pub maxFrameAverageLightLevel:  f32,

}
#[repr(C)]
pub struct VkRefreshCycleDurationGOOGLE {
	pub refreshDuration:  u64,

}
#[repr(C)]
pub struct VkPastPresentationTimingGOOGLE {
	pub presentID:  u32,
	pub desiredPresentTime:  u64,
	pub actualPresentTime:  u64,
	pub earliestPresentTime:  u64,
	pub presentMargin:  u64,

}
#[repr(C)]
pub struct VkPresentTimesInfoGOOGLE {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub swapchainCount:  u32,
	pub pTimes: *const VkPresentTimeGOOGLE,

}
#[repr(C)]
pub struct VkPresentTimeGOOGLE {
	pub presentID:  u32,
	pub desiredPresentTime:  u64,

}
#[repr(C)]
pub struct VkIOSSurfaceCreateInfoMVK {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkIOSSurfaceCreateFlagsMVK,
	pub pView: *const c_void,

}
#[repr(C)]
pub struct VkMacOSSurfaceCreateInfoMVK {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkMacOSSurfaceCreateFlagsMVK,
	pub pView: *const c_void,

}
#[repr(C)]
pub struct VkViewportWScalingNV {
	pub xcoeff:  f32,
	pub ycoeff:  f32,

}
#[repr(C)]
pub struct VkPipelineViewportWScalingStateCreateInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub viewportWScalingEnable:  bool,
	pub viewportCount:  u32,
	pub pViewportWScalings: *const VkViewportWScalingNV,

}
#[repr(C)]
pub struct VkViewportSwizzleNV {
	pub x:  VkViewportCoordinateSwizzleNV,
	pub y:  VkViewportCoordinateSwizzleNV,
	pub z:  VkViewportCoordinateSwizzleNV,
	pub w:  VkViewportCoordinateSwizzleNV,

}
#[repr(C)]
pub struct VkPipelineViewportSwizzleStateCreateInfoNV {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineViewportSwizzleStateCreateFlagsNV,
	pub viewportCount:  u32,
	pub pViewportSwizzles: *const VkViewportSwizzleNV,

}
#[repr(C)]
pub struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub maxDiscardRectangles:  u32,

}
#[repr(C)]
pub struct VkPipelineDiscardRectangleStateCreateInfoEXT {
	pub sType:  VkStructureType,
	pub pNext: *const c_void,
	pub flags:  VkPipelineDiscardRectangleStateCreateFlagsEXT,
	pub discardRectangleMode:  VkDiscardRectangleModeEXT,
	pub discardRectangleCount:  u32,
	pub pDiscardRectangles: *const VkRect2D,

}
#[repr(C)]
pub struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
	pub sType:  VkStructureType,
	pub pNext: *mut c_void,
	pub perViewPositionAllComponents:  bool,

}
#[link(name = "vulkan")]
extern {
	pub fn vkCreateInstance(pCreateInfo: *const VkInstanceCreateInfo, pAllocator: *const VkAllocationCallbacks, pInstance: *mut VkInstance, ) -> VkResult;
	pub fn vkDestroyInstance(instance:  VkInstance, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkEnumeratePhysicalDevices(instance:  VkInstance, pPhysicalDeviceCount: *mut u32, pPhysicalDevices: *mut VkPhysicalDevice, ) -> VkResult;
	pub fn vkGetDeviceProcAddr(device:  VkDevice, pName: *const u8, ) -> PFN_vkVoidFunction;
	pub fn vkGetInstanceProcAddr(instance:  VkInstance, pName: *const u8, ) -> PFN_vkVoidFunction;
	pub fn vkGetPhysicalDeviceProperties(physicalDevice:  VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties, ) -> c_void;
	pub fn vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice:  VkPhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut VkQueueFamilyProperties, ) -> c_void;
	pub fn vkGetPhysicalDeviceMemoryProperties(physicalDevice:  VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties, ) -> c_void;
	pub fn vkGetPhysicalDeviceFeatures(physicalDevice:  VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures, ) -> c_void;
	pub fn vkGetPhysicalDeviceFormatProperties(physicalDevice:  VkPhysicalDevice, format:  VkFormat, pFormatProperties: *mut VkFormatProperties, ) -> c_void;
	pub fn vkGetPhysicalDeviceImageFormatProperties(physicalDevice:  VkPhysicalDevice, format:  VkFormat, _type:  VkImageType, tiling:  VkImageTiling, usage:  VkImageUsageFlags, flags:  VkImageCreateFlags, pImageFormatProperties: *mut VkImageFormatProperties, ) -> VkResult;
	pub fn vkCreateDevice(physicalDevice:  VkPhysicalDevice, pCreateInfo: *const VkDeviceCreateInfo, pAllocator: *const VkAllocationCallbacks, pDevice: *mut VkDevice, ) -> VkResult;
	pub fn vkDestroyDevice(device:  VkDevice, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkEnumerateInstanceLayerProperties(pPropertyCount: *mut u32, pProperties: *mut VkLayerProperties, ) -> VkResult;
	pub fn vkEnumerateInstanceExtensionProperties(pLayerName: *const u8, pPropertyCount: *mut u32, pProperties: *mut VkExtensionProperties, ) -> VkResult;
	pub fn vkEnumerateDeviceLayerProperties(physicalDevice:  VkPhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut VkLayerProperties, ) -> VkResult;
	pub fn vkEnumerateDeviceExtensionProperties(physicalDevice:  VkPhysicalDevice, pLayerName: *const u8, pPropertyCount: *mut u32, pProperties: *mut VkExtensionProperties, ) -> VkResult;
	pub fn vkGetDeviceQueue(device:  VkDevice, queueFamilyIndex:  u32, queueIndex:  u32, pQueue: *mut VkQueue, ) -> c_void;
	pub fn vkQueueSubmit(queue:  VkQueue, submitCount:  u32, pSubmits: *const VkSubmitInfo, fence:  VkFence, ) -> VkResult;
	pub fn vkQueueWaitIdle(queue:  VkQueue, ) -> VkResult;
	pub fn vkDeviceWaitIdle(device:  VkDevice, device:  VkDevice, ) -> VkResult;
	pub fn vkAllocateMemory(device:  VkDevice, pAllocateInfo: *const VkMemoryAllocateInfo, pAllocator: *const VkAllocationCallbacks, pMemory: *mut VkDeviceMemory, ) -> VkResult;
	pub fn vkFreeMemory(device:  VkDevice, memory:  VkDeviceMemory, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkMapMemory(device:  VkDevice, memory:  VkDeviceMemory, offset:  VkDeviceSize, size:  VkDeviceSize, flags:  VkMemoryMapFlags, ppData: *mut c_void, ) -> VkResult;
	pub fn vkUnmapMemory(device:  VkDevice, memory:  VkDeviceMemory, ) -> c_void;
	pub fn vkFlushMappedMemoryRanges(device:  VkDevice, memoryRangeCount:  u32, pMemoryRanges: *const VkMappedMemoryRange, ) -> VkResult;
	pub fn vkInvalidateMappedMemoryRanges(device:  VkDevice, memoryRangeCount:  u32, pMemoryRanges: *const VkMappedMemoryRange, ) -> VkResult;
	pub fn vkGetDeviceMemoryCommitment(device:  VkDevice, memory:  VkDeviceMemory, pCommittedMemoryInBytes: *mut VkDeviceSize, ) -> c_void;
	pub fn vkGetBufferMemoryRequirements(device:  VkDevice, buffer:  VkBuffer, pMemoryRequirements: *mut VkMemoryRequirements, ) -> c_void;
	pub fn vkBindBufferMemory(device:  VkDevice, buffer:  VkBuffer, memory:  VkDeviceMemory, memoryOffset:  VkDeviceSize, ) -> VkResult;
	pub fn vkGetImageMemoryRequirements(device:  VkDevice, image:  VkImage, pMemoryRequirements: *mut VkMemoryRequirements, ) -> c_void;
	pub fn vkBindImageMemory(device:  VkDevice, image:  VkImage, memory:  VkDeviceMemory, memoryOffset:  VkDeviceSize, ) -> VkResult;
	pub fn vkGetImageSparseMemoryRequirements(device:  VkDevice, image:  VkImage, pSparseMemoryRequirementCount: *mut u32, pSparseMemoryRequirements: *mut VkSparseImageMemoryRequirements, ) -> c_void;
	pub fn vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice:  VkPhysicalDevice, format:  VkFormat, _type:  VkImageType, samples:  VkSampleCountFlagBits, usage:  VkImageUsageFlags, tiling:  VkImageTiling, pPropertyCount: *mut u32, pProperties: *mut VkSparseImageFormatProperties, ) -> c_void;
	pub fn vkQueueBindSparse(queue:  VkQueue, bindInfoCount:  u32, pBindInfo: *const VkBindSparseInfo, fence:  VkFence, ) -> VkResult;
	pub fn vkCreateFence(device:  VkDevice, pCreateInfo: *const VkFenceCreateInfo, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence, ) -> VkResult;
	pub fn vkDestroyFence(device:  VkDevice, fence:  VkFence, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkResetFences(device:  VkDevice, fenceCount:  u32, pFences: *const VkFence, ) -> VkResult;
	pub fn vkGetFenceStatus(device:  VkDevice, fence:  VkFence, ) -> VkResult;
	pub fn vkWaitForFences(device:  VkDevice, fenceCount:  u32, pFences: *const VkFence, waitAll:  bool, timeout:  u64, ) -> VkResult;
	pub fn vkCreateSemaphore(device:  VkDevice, pCreateInfo: *const VkSemaphoreCreateInfo, pAllocator: *const VkAllocationCallbacks, pSemaphore: *mut VkSemaphore, ) -> VkResult;
	pub fn vkDestroySemaphore(device:  VkDevice, semaphore:  VkSemaphore, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateEvent(device:  VkDevice, pCreateInfo: *const VkEventCreateInfo, pAllocator: *const VkAllocationCallbacks, pEvent: *mut VkEvent, ) -> VkResult;
	pub fn vkDestroyEvent(device:  VkDevice, event:  VkEvent, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkGetEventStatus(device:  VkDevice, event:  VkEvent, ) -> VkResult;
	pub fn vkSetEvent(device:  VkDevice, event:  VkEvent, ) -> VkResult;
	pub fn vkResetEvent(device:  VkDevice, event:  VkEvent, ) -> VkResult;
	pub fn vkCreateQueryPool(device:  VkDevice, pCreateInfo: *const VkQueryPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pQueryPool: *mut VkQueryPool, ) -> VkResult;
	pub fn vkDestroyQueryPool(device:  VkDevice, queryPool:  VkQueryPool, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkGetQueryPoolResults(device:  VkDevice, queryPool:  VkQueryPool, firstQuery:  u32, queryCount:  u32, dataSize:  size_t, pData: *mut c_void, stride:  VkDeviceSize, flags:  VkQueryResultFlags, ) -> VkResult;
	pub fn vkCreateBuffer(device:  VkDevice, pCreateInfo: *const VkBufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pBuffer: *mut VkBuffer, ) -> VkResult;
	pub fn vkDestroyBuffer(device:  VkDevice, buffer:  VkBuffer, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateBufferView(device:  VkDevice, pCreateInfo: *const VkBufferViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkBufferView, ) -> VkResult;
	pub fn vkDestroyBufferView(device:  VkDevice, bufferView:  VkBufferView, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateImage(device:  VkDevice, pCreateInfo: *const VkImageCreateInfo, pAllocator: *const VkAllocationCallbacks, pImage: *mut VkImage, ) -> VkResult;
	pub fn vkDestroyImage(device:  VkDevice, image:  VkImage, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkGetImageSubresourceLayout(device:  VkDevice, image:  VkImage, pSubresource: *const VkImageSubresource, pLayout: *mut VkSubresourceLayout, ) -> c_void;
	pub fn vkCreateImageView(device:  VkDevice, pCreateInfo: *const VkImageViewCreateInfo, pAllocator: *const VkAllocationCallbacks, pView: *mut VkImageView, ) -> VkResult;
	pub fn vkDestroyImageView(device:  VkDevice, imageView:  VkImageView, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateShaderModule(device:  VkDevice, pCreateInfo: *const VkShaderModuleCreateInfo, pAllocator: *const VkAllocationCallbacks, pShaderModule: *mut VkShaderModule, ) -> VkResult;
	pub fn vkDestroyShaderModule(device:  VkDevice, shaderModule:  VkShaderModule, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreatePipelineCache(device:  VkDevice, pCreateInfo: *const VkPipelineCacheCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineCache: *mut VkPipelineCache, ) -> VkResult;
	pub fn vkDestroyPipelineCache(device:  VkDevice, pipelineCache:  VkPipelineCache, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkGetPipelineCacheData(device:  VkDevice, pipelineCache:  VkPipelineCache, pDataSize: *mut size_t, pData: *mut c_void, ) -> VkResult;
	pub fn vkMergePipelineCaches(device:  VkDevice, dstCache:  VkPipelineCache, srcCacheCount:  u32, pSrcCaches: *const VkPipelineCache, ) -> VkResult;
	pub fn vkCreateGraphicsPipelines(device:  VkDevice, pipelineCache:  VkPipelineCache, createInfoCount:  u32, pCreateInfos: *const VkGraphicsPipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline, ) -> VkResult;
	pub fn vkCreateComputePipelines(device:  VkDevice, pipelineCache:  VkPipelineCache, createInfoCount:  u32, pCreateInfos: *const VkComputePipelineCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelines: *mut VkPipeline, ) -> VkResult;
	pub fn vkDestroyPipeline(device:  VkDevice, pipeline:  VkPipeline, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreatePipelineLayout(device:  VkDevice, pCreateInfo: *const VkPipelineLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pPipelineLayout: *mut VkPipelineLayout, ) -> VkResult;
	pub fn vkDestroyPipelineLayout(device:  VkDevice, pipelineLayout:  VkPipelineLayout, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateSampler(device:  VkDevice, pCreateInfo: *const VkSamplerCreateInfo, pAllocator: *const VkAllocationCallbacks, pSampler: *mut VkSampler, ) -> VkResult;
	pub fn vkDestroySampler(device:  VkDevice, sampler:  VkSampler, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateDescriptorSetLayout(device:  VkDevice, pCreateInfo: *const VkDescriptorSetLayoutCreateInfo, pAllocator: *const VkAllocationCallbacks, pSetLayout: *mut VkDescriptorSetLayout, ) -> VkResult;
	pub fn vkDestroyDescriptorSetLayout(device:  VkDevice, descriptorSetLayout:  VkDescriptorSetLayout, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateDescriptorPool(device:  VkDevice, pCreateInfo: *const VkDescriptorPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pDescriptorPool: *mut VkDescriptorPool, ) -> VkResult;
	pub fn vkDestroyDescriptorPool(device:  VkDevice, descriptorPool:  VkDescriptorPool, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkResetDescriptorPool(device:  VkDevice, descriptorPool:  VkDescriptorPool, flags:  VkDescriptorPoolResetFlags, flags:  VkDescriptorPoolResetFlags, ) -> VkResult;
	pub fn vkAllocateDescriptorSets(device:  VkDevice, pAllocateInfo: *const VkDescriptorSetAllocateInfo, pDescriptorSets: *mut VkDescriptorSet, ) -> VkResult;
	pub fn vkFreeDescriptorSets(device:  VkDevice, descriptorPool:  VkDescriptorPool, descriptorSetCount:  u32, pDescriptorSets: *const VkDescriptorSet, ) -> VkResult;
	pub fn vkUpdateDescriptorSets(device:  VkDevice, descriptorWriteCount:  u32, pDescriptorWrites: *const VkWriteDescriptorSet, descriptorCopyCount:  u32, pDescriptorCopies: *const VkCopyDescriptorSet, ) -> c_void;
	pub fn vkCreateFramebuffer(device:  VkDevice, pCreateInfo: *const VkFramebufferCreateInfo, pAllocator: *const VkAllocationCallbacks, pFramebuffer: *mut VkFramebuffer, ) -> VkResult;
	pub fn vkDestroyFramebuffer(device:  VkDevice, framebuffer:  VkFramebuffer, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateRenderPass(device:  VkDevice, pCreateInfo: *const VkRenderPassCreateInfo, pAllocator: *const VkAllocationCallbacks, pRenderPass: *mut VkRenderPass, ) -> VkResult;
	pub fn vkDestroyRenderPass(device:  VkDevice, renderPass:  VkRenderPass, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkGetRenderAreaGranularity(device:  VkDevice, renderPass:  VkRenderPass, pGranularity: *mut VkExtent2D, ) -> c_void;
	pub fn vkCreateCommandPool(device:  VkDevice, pCreateInfo: *const VkCommandPoolCreateInfo, pAllocator: *const VkAllocationCallbacks, pCommandPool: *mut VkCommandPool, ) -> VkResult;
	pub fn vkDestroyCommandPool(device:  VkDevice, commandPool:  VkCommandPool, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkResetCommandPool(device:  VkDevice, commandPool:  VkCommandPool, flags:  VkCommandPoolResetFlags, ) -> VkResult;
	pub fn vkAllocateCommandBuffers(device:  VkDevice, pAllocateInfo: *const VkCommandBufferAllocateInfo, pCommandBuffers: *mut VkCommandBuffer, ) -> VkResult;
	pub fn vkFreeCommandBuffers(device:  VkDevice, commandPool:  VkCommandPool, commandBufferCount:  u32, pCommandBuffers: *const VkCommandBuffer, ) -> c_void;
	pub fn vkBeginCommandBuffer(commandBuffer:  VkCommandBuffer, pBeginInfo: *const VkCommandBufferBeginInfo, pBeginInfo:  VkCommandBufferBeginInfo, ) -> VkResult;
	pub fn vkEndCommandBuffer(commandBuffer:  VkCommandBuffer, commandBuffer:  VkCommandBuffer, ) -> VkResult;
	pub fn vkResetCommandBuffer(commandBuffer:  VkCommandBuffer, flags:  VkCommandBufferResetFlags, ) -> VkResult;
	pub fn vkCmdBindPipeline(commandBuffer:  VkCommandBuffer, pipelineBindPoint:  VkPipelineBindPoint, pipeline:  VkPipeline, ) -> c_void;
	pub fn vkCmdSetViewport(commandBuffer:  VkCommandBuffer, firstViewport:  u32, viewportCount:  u32, pViewports: *const VkViewport, ) -> c_void;
	pub fn vkCmdSetScissor(commandBuffer:  VkCommandBuffer, firstScissor:  u32, scissorCount:  u32, pScissors: *const VkRect2D, ) -> c_void;
	pub fn vkCmdSetLineWidth(commandBuffer:  VkCommandBuffer, lineWidth:  f32, ) -> c_void;
	pub fn vkCmdSetDepthBias(commandBuffer:  VkCommandBuffer, depthBiasConstantFactor:  f32, depthBiasClamp:  f32, depthBiasSlopeFactor:  f32, ) -> c_void;
	pub fn vkCmdSetBlendConstants(commandBuffer:  VkCommandBuffer, blendConstants: [ f32; 4], ) -> c_void;
	pub fn vkCmdSetDepthBounds(commandBuffer:  VkCommandBuffer, minDepthBounds:  f32, maxDepthBounds:  f32, ) -> c_void;
	pub fn vkCmdSetStencilCompareMask(commandBuffer:  VkCommandBuffer, faceMask:  VkStencilFaceFlags, compareMask:  u32, ) -> c_void;
	pub fn vkCmdSetStencilWriteMask(commandBuffer:  VkCommandBuffer, faceMask:  VkStencilFaceFlags, writeMask:  u32, ) -> c_void;
	pub fn vkCmdSetStencilReference(commandBuffer:  VkCommandBuffer, faceMask:  VkStencilFaceFlags, reference:  u32, ) -> c_void;
	pub fn vkCmdBindDescriptorSets(commandBuffer:  VkCommandBuffer, pipelineBindPoint:  VkPipelineBindPoint, layout:  VkPipelineLayout, firstSet:  u32, descriptorSetCount:  u32, pDescriptorSets: *const VkDescriptorSet, dynamicOffsetCount:  u32, pDynamicOffsets: *const u32, ) -> c_void;
	pub fn vkCmdBindIndexBuffer(commandBuffer:  VkCommandBuffer, buffer:  VkBuffer, offset:  VkDeviceSize, indexType:  VkIndexType, ) -> c_void;
	pub fn vkCmdBindVertexBuffers(commandBuffer:  VkCommandBuffer, firstBinding:  u32, bindingCount:  u32, pBuffers: *const VkBuffer, pOffsets: *const VkDeviceSize, ) -> c_void;
	pub fn vkCmdDraw(commandBuffer:  VkCommandBuffer, vertexCount:  u32, instanceCount:  u32, firstVertex:  u32, firstInstance:  u32, ) -> c_void;
	pub fn vkCmdDrawIndexed(commandBuffer:  VkCommandBuffer, indexCount:  u32, instanceCount:  u32, firstIndex:  u32, vertexOffset:  i32, firstInstance:  u32, ) -> c_void;
	pub fn vkCmdDrawIndirect(commandBuffer:  VkCommandBuffer, buffer:  VkBuffer, offset:  VkDeviceSize, drawCount:  u32, stride:  u32, ) -> c_void;
	pub fn vkCmdDrawIndexedIndirect(commandBuffer:  VkCommandBuffer, buffer:  VkBuffer, offset:  VkDeviceSize, drawCount:  u32, stride:  u32, ) -> c_void;
	pub fn vkCmdDispatch(commandBuffer:  VkCommandBuffer, groupCountX:  u32, groupCountY:  u32, groupCountZ:  u32, ) -> c_void;
	pub fn vkCmdDispatchIndirect(commandBuffer:  VkCommandBuffer, buffer:  VkBuffer, offset:  VkDeviceSize, ) -> c_void;
	pub fn vkCmdCopyBuffer(commandBuffer:  VkCommandBuffer, srcBuffer:  VkBuffer, dstBuffer:  VkBuffer, regionCount:  u32, pRegions: *const VkBufferCopy, ) -> c_void;
	pub fn vkCmdCopyImage(commandBuffer:  VkCommandBuffer, srcImage:  VkImage, srcImageLayout:  VkImageLayout, dstImage:  VkImage, dstImageLayout:  VkImageLayout, regionCount:  u32, pRegions: *const VkImageCopy, ) -> c_void;
	pub fn vkCmdBlitImage(commandBuffer:  VkCommandBuffer, srcImage:  VkImage, srcImageLayout:  VkImageLayout, dstImage:  VkImage, dstImageLayout:  VkImageLayout, regionCount:  u32, pRegions: *const VkImageBlit, filter:  VkFilter, ) -> c_void;
	pub fn vkCmdCopyBufferToImage(commandBuffer:  VkCommandBuffer, srcBuffer:  VkBuffer, dstImage:  VkImage, dstImageLayout:  VkImageLayout, regionCount:  u32, pRegions: *const VkBufferImageCopy, ) -> c_void;
	pub fn vkCmdCopyImageToBuffer(commandBuffer:  VkCommandBuffer, srcImage:  VkImage, srcImageLayout:  VkImageLayout, dstBuffer:  VkBuffer, regionCount:  u32, pRegions: *const VkBufferImageCopy, ) -> c_void;
	pub fn vkCmdUpdateBuffer(commandBuffer:  VkCommandBuffer, dstBuffer:  VkBuffer, dstOffset:  VkDeviceSize, dataSize:  VkDeviceSize, pData: *const c_void, ) -> c_void;
	pub fn vkCmdFillBuffer(commandBuffer:  VkCommandBuffer, dstBuffer:  VkBuffer, dstOffset:  VkDeviceSize, size:  VkDeviceSize, data:  u32, ) -> c_void;
	pub fn vkCmdClearColorImage(commandBuffer:  VkCommandBuffer, image:  VkImage, imageLayout:  VkImageLayout, pColor: *const VkClearColorValue, rangeCount:  u32, pRanges: *const VkImageSubresourceRange, ) -> c_void;
	pub fn vkCmdClearDepthStencilImage(commandBuffer:  VkCommandBuffer, image:  VkImage, imageLayout:  VkImageLayout, pDepthStencil: *const VkClearDepthStencilValue, rangeCount:  u32, pRanges: *const VkImageSubresourceRange, ) -> c_void;
	pub fn vkCmdClearAttachments(commandBuffer:  VkCommandBuffer, attachmentCount:  u32, pAttachments: *const VkClearAttachment, rectCount:  u32, pRects: *const VkClearRect, ) -> c_void;
	pub fn vkCmdResolveImage(commandBuffer:  VkCommandBuffer, srcImage:  VkImage, srcImageLayout:  VkImageLayout, dstImage:  VkImage, dstImageLayout:  VkImageLayout, regionCount:  u32, pRegions: *const VkImageResolve, ) -> c_void;
	pub fn vkCmdSetEvent(commandBuffer:  VkCommandBuffer, event:  VkEvent, stageMask:  VkPipelineStageFlags, ) -> c_void;
	pub fn vkCmdResetEvent(commandBuffer:  VkCommandBuffer, event:  VkEvent, stageMask:  VkPipelineStageFlags, ) -> c_void;
	pub fn vkCmdWaitEvents(commandBuffer:  VkCommandBuffer, eventCount:  u32, pEvents: *const VkEvent, srcStageMask:  VkPipelineStageFlags, dstStageMask:  VkPipelineStageFlags, memoryBarrierCount:  u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount:  u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount:  u32, pImageMemoryBarriers: *const VkImageMemoryBarrier, ) -> c_void;
	pub fn vkCmdPipelineBarrier(commandBuffer:  VkCommandBuffer, srcStageMask:  VkPipelineStageFlags, dstStageMask:  VkPipelineStageFlags, dependencyFlags:  VkDependencyFlags, memoryBarrierCount:  u32, pMemoryBarriers: *const VkMemoryBarrier, bufferMemoryBarrierCount:  u32, pBufferMemoryBarriers: *const VkBufferMemoryBarrier, imageMemoryBarrierCount:  u32, pImageMemoryBarriers: *const VkImageMemoryBarrier, ) -> c_void;
	pub fn vkCmdBeginQuery(commandBuffer:  VkCommandBuffer, queryPool:  VkQueryPool, query:  u32, flags:  VkQueryControlFlags, ) -> c_void;
	pub fn vkCmdEndQuery(commandBuffer:  VkCommandBuffer, queryPool:  VkQueryPool, query:  u32, ) -> c_void;
	pub fn vkCmdResetQueryPool(commandBuffer:  VkCommandBuffer, queryPool:  VkQueryPool, firstQuery:  u32, queryCount:  u32, ) -> c_void;
	pub fn vkCmdWriteTimestamp(commandBuffer:  VkCommandBuffer, pipelineStage:  VkPipelineStageFlagBits, queryPool:  VkQueryPool, query:  u32, ) -> c_void;
	pub fn vkCmdCopyQueryPoolResults(commandBuffer:  VkCommandBuffer, queryPool:  VkQueryPool, firstQuery:  u32, queryCount:  u32, dstBuffer:  VkBuffer, dstOffset:  VkDeviceSize, stride:  VkDeviceSize, flags:  VkQueryResultFlags, ) -> c_void;
	pub fn vkCmdPushConstants(commandBuffer:  VkCommandBuffer, layout:  VkPipelineLayout, stageFlags:  VkShaderStageFlags, offset:  u32, size:  u32, pValues: *const c_void, ) -> c_void;
	pub fn vkCmdBeginRenderPass(commandBuffer:  VkCommandBuffer, pRenderPassBegin: *const VkRenderPassBeginInfo, contents:  VkSubpassContents, ) -> c_void;
	pub fn vkCmdNextSubpass(commandBuffer:  VkCommandBuffer, contents:  VkSubpassContents, ) -> c_void;
	pub fn vkCmdEndRenderPass(commandBuffer:  VkCommandBuffer, ) -> c_void;
	pub fn vkCmdExecuteCommands(commandBuffer:  VkCommandBuffer, commandBufferCount:  u32, pCommandBuffers: *const VkCommandBuffer, ) -> c_void;
	pub fn vkCreateAndroidSurfaceKHR(instance:  VkInstance, pCreateInfo: *const VkAndroidSurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice:  VkPhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut VkDisplayPropertiesKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice:  VkPhysicalDevice, pPropertyCount: *mut u32, pProperties: *mut VkDisplayPlanePropertiesKHR, ) -> VkResult;
	pub fn vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice:  VkPhysicalDevice, planeIndex:  u32, pDisplayCount: *mut u32, pDisplays: *mut VkDisplayKHR, ) -> VkResult;
	pub fn vkGetDisplayModePropertiesKHR(physicalDevice:  VkPhysicalDevice, display:  VkDisplayKHR, pPropertyCount: *mut u32, pProperties: *mut VkDisplayModePropertiesKHR, ) -> VkResult;
	pub fn vkCreateDisplayModeKHR(physicalDevice:  VkPhysicalDevice, display:  VkDisplayKHR, pCreateInfo: *const VkDisplayModeCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pMode: *mut VkDisplayModeKHR, ) -> VkResult;
	pub fn vkGetDisplayPlaneCapabilitiesKHR(physicalDevice:  VkPhysicalDevice, mode:  VkDisplayModeKHR, planeIndex:  u32, pCapabilities: *mut VkDisplayPlaneCapabilitiesKHR, ) -> VkResult;
	pub fn vkCreateDisplayPlaneSurfaceKHR(instance:  VkInstance, pCreateInfo: *const VkDisplaySurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkCreateSharedSwapchainsKHR(device:  VkDevice, swapchainCount:  u32, pCreateInfos: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchains: *mut VkSwapchainKHR, ) -> VkResult;
	pub fn vkCreateMirSurfaceKHR(instance:  VkInstance, pCreateInfo: *const VkMirSurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceMirPresentationSupportKHR(physicalDevice:  VkPhysicalDevice, queueFamilyIndex:  u32, connection: *mut MirConnection, ) -> bool;
	pub fn vkDestroySurfaceKHR(instance:  VkInstance, surface:  VkSurfaceKHR, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice:  VkPhysicalDevice, queueFamilyIndex:  u32, surface:  VkSurfaceKHR, pSupported: *mut bool, ) -> VkResult;
	pub fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice:  VkPhysicalDevice, surface:  VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilitiesKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice:  VkPhysicalDevice, surface:  VkSurfaceKHR, pSurfaceFormatCount: *mut u32, pSurfaceFormats: *mut VkSurfaceFormatKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice:  VkPhysicalDevice, surface:  VkSurfaceKHR, pPresentModeCount: *mut u32, pPresentModes: *mut VkPresentModeKHR, ) -> VkResult;
	pub fn vkCreateSwapchainKHR(device:  VkDevice, pCreateInfo: *const VkSwapchainCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSwapchain: *mut VkSwapchainKHR, ) -> VkResult;
	pub fn vkDestroySwapchainKHR(device:  VkDevice, swapchain:  VkSwapchainKHR, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkGetSwapchainImagesKHR(device:  VkDevice, swapchain:  VkSwapchainKHR, pSwapchainImageCount: *mut u32, pSwapchainImages: *mut VkImage, ) -> VkResult;
	pub fn vkAcquireNextImageKHR(device:  VkDevice, swapchain:  VkSwapchainKHR, timeout:  u64, semaphore:  VkSemaphore, fence:  VkFence, pImageIndex: *mut u32, ) -> VkResult;
	pub fn vkQueuePresentKHR(queue:  VkQueue, pPresentInfo: *const VkPresentInfoKHR, ) -> VkResult;
	pub fn vkCreateViSurfaceNN(instance:  VkInstance, pCreateInfo: *const VkViSurfaceCreateInfoNN, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkCreateWaylandSurfaceKHR(instance:  VkInstance, pCreateInfo: *const VkWaylandSurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceWaylandPresentationSupportKHR(physicalDevice:  VkPhysicalDevice, queueFamilyIndex:  u32, display: *mut wl_display, ) -> bool;
	pub fn vkCreateWin32SurfaceKHR(instance:  VkInstance, pCreateInfo: *const VkWin32SurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceWin32PresentationSupportKHR(physicalDevice:  VkPhysicalDevice, queueFamilyIndex:  u32, ) -> bool;
	pub fn vkCreateXlibSurfaceKHR(instance:  VkInstance, pCreateInfo: *const VkXlibSurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceXlibPresentationSupportKHR(physicalDevice:  VkPhysicalDevice, queueFamilyIndex:  u32, dpy: *mut Display, visualID:  VisualID, ) -> bool;
	pub fn vkCreateXcbSurfaceKHR(instance:  VkInstance, pCreateInfo: *const VkXcbSurfaceCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceXcbPresentationSupportKHR(physicalDevice:  VkPhysicalDevice, queueFamilyIndex:  u32, connection: *mut xcb_connection_t, visual_id:  xcb_visualid_t, ) -> bool;
	pub fn vkCreateDebugReportCallbackEXT(instance:  VkInstance, pCreateInfo: *const VkDebugReportCallbackCreateInfoEXT, pAllocator: *const VkAllocationCallbacks, pCallback: *mut VkDebugReportCallbackEXT, ) -> VkResult;
	pub fn vkDestroyDebugReportCallbackEXT(instance:  VkInstance, callback:  VkDebugReportCallbackEXT, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkDebugReportMessageEXT(instance:  VkInstance, flags:  VkDebugReportFlagsEXT, objectType:  VkDebugReportObjectTypeEXT, object:  u64, location:  size_t, messageCode:  i32, pLayerPrefix: *const u8, pMessage: *const u8, ) -> c_void;
	pub fn vkDebugMarkerSetObjectNameEXT(device:  VkDevice, pNameInfo: *mut VkDebugMarkerObjectNameInfoEXT, ) -> VkResult;
	pub fn vkDebugMarkerSetObjectTagEXT(device:  VkDevice, pTagInfo: *mut VkDebugMarkerObjectTagInfoEXT, ) -> VkResult;
	pub fn vkCmdDebugMarkerBeginEXT(commandBuffer:  VkCommandBuffer, pMarkerInfo: *mut VkDebugMarkerMarkerInfoEXT, ) -> c_void;
	pub fn vkCmdDebugMarkerEndEXT(commandBuffer:  VkCommandBuffer, ) -> c_void;
	pub fn vkCmdDebugMarkerInsertEXT(commandBuffer:  VkCommandBuffer, pMarkerInfo: *mut VkDebugMarkerMarkerInfoEXT, ) -> c_void;
	pub fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice:  VkPhysicalDevice, format:  VkFormat, _type:  VkImageType, tiling:  VkImageTiling, usage:  VkImageUsageFlags, flags:  VkImageCreateFlags, externalHandleType:  VkExternalMemoryHandleTypeFlagsNV, pExternalImageFormatProperties: *mut VkExternalImageFormatPropertiesNV, ) -> VkResult;
	pub fn vkGetMemoryWin32HandleNV(device:  VkDevice, memory:  VkDeviceMemory, handleType:  VkExternalMemoryHandleTypeFlagsNV, pHandle: *mut HANDLE, ) -> VkResult;
	pub fn vkCmdDrawIndirectCountAMD(commandBuffer:  VkCommandBuffer, buffer:  VkBuffer, offset:  VkDeviceSize, countBuffer:  VkBuffer, countBufferOffset:  VkDeviceSize, maxDrawCount:  u32, stride:  u32, ) -> c_void;
	pub fn vkCmdDrawIndexedIndirectCountAMD(commandBuffer:  VkCommandBuffer, buffer:  VkBuffer, offset:  VkDeviceSize, countBuffer:  VkBuffer, countBufferOffset:  VkDeviceSize, maxDrawCount:  u32, stride:  u32, ) -> c_void;
	pub fn vkCmdProcessCommandsNVX(commandBuffer:  VkCommandBuffer, pProcessCommandsInfo: *const VkCmdProcessCommandsInfoNVX, ) -> c_void;
	pub fn vkCmdReserveSpaceForCommandsNVX(commandBuffer:  VkCommandBuffer, pReserveSpaceInfo: *const VkCmdReserveSpaceForCommandsInfoNVX, ) -> c_void;
	pub fn vkCreateIndirectCommandsLayoutNVX(device:  VkDevice, pCreateInfo: *const VkIndirectCommandsLayoutCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pIndirectCommandsLayout: *mut VkIndirectCommandsLayoutNVX, ) -> VkResult;
	pub fn vkDestroyIndirectCommandsLayoutNVX(device:  VkDevice, indirectCommandsLayout:  VkIndirectCommandsLayoutNVX, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkCreateObjectTableNVX(device:  VkDevice, pCreateInfo: *const VkObjectTableCreateInfoNVX, pAllocator: *const VkAllocationCallbacks, pObjectTable: *mut VkObjectTableNVX, ) -> VkResult;
	pub fn vkDestroyObjectTableNVX(device:  VkDevice, objectTable:  VkObjectTableNVX, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkRegisterObjectsNVX(device:  VkDevice, objectTable:  VkObjectTableNVX, objectCount:  u32, ppObjectTableEntries: *const VkObjectTableEntryNVX, pObjectIndices: *const u32, ) -> VkResult;
	pub fn vkUnregisterObjectsNVX(device:  VkDevice, objectTable:  VkObjectTableNVX, objectCount:  u32, pObjectEntryTypes: *const VkObjectEntryTypeNVX, pObjectIndices: *const u32, ) -> VkResult;
	pub fn vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice:  VkPhysicalDevice, pFeatures: *mut VkDeviceGeneratedCommandsFeaturesNVX, pLimits: *mut VkDeviceGeneratedCommandsLimitsNVX, ) -> c_void;
	pub fn vkGetPhysicalDeviceFeatures2KHR(physicalDevice:  VkPhysicalDevice, pFeatures: *mut VkPhysicalDeviceFeatures2KHR, ) -> c_void;
	pub fn vkGetPhysicalDeviceProperties2KHR(physicalDevice:  VkPhysicalDevice, pProperties: *mut VkPhysicalDeviceProperties2KHR, ) -> c_void;
	pub fn vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice:  VkPhysicalDevice, format:  VkFormat, pFormatProperties: *mut VkFormatProperties2KHR, ) -> c_void;
	pub fn vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice:  VkPhysicalDevice, pImageFormatInfo: *const VkPhysicalDeviceImageFormatInfo2KHR, pImageFormatProperties: *mut VkImageFormatProperties2KHR, ) -> VkResult;
	pub fn vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice:  VkPhysicalDevice, pQueueFamilyPropertyCount: *mut u32, pQueueFamilyProperties: *mut VkQueueFamilyProperties2KHR, ) -> c_void;
	pub fn vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice:  VkPhysicalDevice, pMemoryProperties: *mut VkPhysicalDeviceMemoryProperties2KHR, ) -> c_void;
	pub fn vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice:  VkPhysicalDevice, pFormatInfo: *const VkPhysicalDeviceSparseImageFormatInfo2KHR, pPropertyCount: *mut u32, pProperties: *mut VkSparseImageFormatProperties2KHR, ) -> c_void;
	pub fn vkCmdPushDescriptorSetKHR(commandBuffer:  VkCommandBuffer, pipelineBindPoint:  VkPipelineBindPoint, layout:  VkPipelineLayout, set:  u32, descriptorWriteCount:  u32, pDescriptorWrites: *const VkWriteDescriptorSet, ) -> c_void;
	pub fn vkTrimCommandPoolKHR(device:  VkDevice, commandPool:  VkCommandPool, flags:  VkCommandPoolTrimFlagsKHR, ) -> c_void;
	pub fn vkGetPhysicalDeviceExternalBufferPropertiesKHX(physicalDevice:  VkPhysicalDevice, pExternalBufferInfo: *const VkPhysicalDeviceExternalBufferInfoKHX, pExternalBufferProperties: *mut VkExternalBufferPropertiesKHX, ) -> c_void;
	pub fn vkGetMemoryWin32HandleKHX(device:  VkDevice, memory:  VkDeviceMemory, handleType:  VkExternalMemoryHandleTypeFlagBitsKHX, pHandle: *mut HANDLE, ) -> VkResult;
	pub fn vkGetMemoryWin32HandlePropertiesKHX(device:  VkDevice, handleType:  VkExternalMemoryHandleTypeFlagBitsKHX, handle:  HANDLE, pMemoryWin32HandleProperties: *mut VkMemoryWin32HandlePropertiesKHX, ) -> VkResult;
	pub fn vkGetMemoryFdKHX(device:  VkDevice, memory:  VkDeviceMemory, handleType:  VkExternalMemoryHandleTypeFlagBitsKHX, pFd: *mut i32, ) -> VkResult;
	pub fn vkGetMemoryFdPropertiesKHX(device:  VkDevice, handleType:  VkExternalMemoryHandleTypeFlagBitsKHX, fd:  i32, pMemoryFdProperties: *mut VkMemoryFdPropertiesKHX, ) -> VkResult;
	pub fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHX(physicalDevice:  VkPhysicalDevice, pExternalSemaphoreInfo: *const VkPhysicalDeviceExternalSemaphoreInfoKHX, pExternalSemaphoreProperties: *mut VkExternalSemaphorePropertiesKHX, ) -> c_void;
	pub fn vkGetSemaphoreWin32HandleKHX(device:  VkDevice, semaphore:  VkSemaphore, handleType:  VkExternalSemaphoreHandleTypeFlagBitsKHX, pHandle: *mut HANDLE, ) -> VkResult;
	pub fn vkImportSemaphoreWin32HandleKHX(device:  VkDevice, pImportSemaphoreWin32HandleInfo: *const VkImportSemaphoreWin32HandleInfoKHX, ) -> VkResult;
	pub fn vkGetSemaphoreFdKHX(device:  VkDevice, semaphore:  VkSemaphore, handleType:  VkExternalSemaphoreHandleTypeFlagBitsKHX, pFd: *mut i32, ) -> VkResult;
	pub fn vkImportSemaphoreFdKHX(device:  VkDevice, pImportSemaphoreFdInfo: *const VkImportSemaphoreFdInfoKHX, ) -> VkResult;
	pub fn vkReleaseDisplayEXT(physicalDevice:  VkPhysicalDevice, display:  VkDisplayKHR, ) -> VkResult;
	pub fn vkAcquireXlibDisplayEXT(physicalDevice:  VkPhysicalDevice, dpy: *mut Display, display:  VkDisplayKHR, ) -> VkResult;
	pub fn vkGetRandROutputDisplayEXT(physicalDevice:  VkPhysicalDevice, dpy: *mut Display, rrOutput:  RROutput, pDisplay: *mut VkDisplayKHR, ) -> VkResult;
	pub fn vkDisplayPowerControlEXT(device:  VkDevice, display:  VkDisplayKHR, pDisplayPowerInfo: *const VkDisplayPowerInfoEXT, ) -> VkResult;
	pub fn vkRegisterDeviceEventEXT(device:  VkDevice, pDeviceEventInfo: *const VkDeviceEventInfoEXT, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence, ) -> VkResult;
	pub fn vkRegisterDisplayEventEXT(device:  VkDevice, display:  VkDisplayKHR, pDisplayEventInfo: *const VkDisplayEventInfoEXT, pAllocator: *const VkAllocationCallbacks, pFence: *mut VkFence, ) -> VkResult;
	pub fn vkGetSwapchainCounterEXT(device:  VkDevice, swapchain:  VkSwapchainKHR, counter:  VkSurfaceCounterFlagBitsEXT, pCounterValue: *mut u64, ) -> VkResult;
	pub fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice:  VkPhysicalDevice, surface:  VkSurfaceKHR, pSurfaceCapabilities: *mut VkSurfaceCapabilities2EXT, ) -> VkResult;
	pub fn vkEnumeratePhysicalDeviceGroupsKHX(instance:  VkInstance, pPhysicalDeviceGroupCount: *mut u32, pPhysicalDeviceGroupProperties: *mut VkPhysicalDeviceGroupPropertiesKHX, ) -> VkResult;
	pub fn vkGetDeviceGroupPeerMemoryFeaturesKHX(device:  VkDevice, heapIndex:  u32, localDeviceIndex:  u32, remoteDeviceIndex:  u32, pPeerMemoryFeatures: *mut VkPeerMemoryFeatureFlagsKHX, ) -> c_void;
	pub fn vkBindBufferMemory2KHX(device:  VkDevice, bindInfoCount:  u32, pBindInfos: *const VkBindBufferMemoryInfoKHX, ) -> VkResult;
	pub fn vkBindImageMemory2KHX(device:  VkDevice, bindInfoCount:  u32, pBindInfos: *const VkBindImageMemoryInfoKHX, ) -> VkResult;
	pub fn vkCmdSetDeviceMaskKHX(commandBuffer:  VkCommandBuffer, deviceMask:  u32, ) -> c_void;
	pub fn vkGetDeviceGroupPresentCapabilitiesKHX(device:  VkDevice, pDeviceGroupPresentCapabilities: *mut VkDeviceGroupPresentCapabilitiesKHX, ) -> VkResult;
	pub fn vkGetDeviceGroupSurfacePresentModesKHX(device:  VkDevice, surface:  VkSurfaceKHR, pModes: *mut VkDeviceGroupPresentModeFlagsKHX, ) -> VkResult;
	pub fn vkAcquireNextImage2KHX(device:  VkDevice, pAcquireInfo: *const VkAcquireNextImageInfoKHX, pImageIndex: *mut u32, ) -> VkResult;
	pub fn vkCmdDispatchBaseKHX(commandBuffer:  VkCommandBuffer, baseGroupX:  u32, baseGroupY:  u32, baseGroupZ:  u32, groupCountX:  u32, groupCountY:  u32, groupCountZ:  u32, ) -> c_void;
	pub fn vkGetPhysicalDevicePresentRectanglesKHX(physicalDevice:  VkPhysicalDevice, surface:  VkSurfaceKHR, pRectCount: *mut u32, pRects: *mut VkRect2D, ) -> VkResult;
	pub fn vkCreateDescriptorUpdateTemplateKHR(device:  VkDevice, pCreateInfo: *const VkDescriptorUpdateTemplateCreateInfoKHR, pAllocator: *const VkAllocationCallbacks, pDescriptorUpdateTemplate: *mut VkDescriptorUpdateTemplateKHR, ) -> VkResult;
	pub fn vkDestroyDescriptorUpdateTemplateKHR(device:  VkDevice, descriptorUpdateTemplate:  VkDescriptorUpdateTemplateKHR, pAllocator: *const VkAllocationCallbacks, ) -> c_void;
	pub fn vkUpdateDescriptorSetWithTemplateKHR(device:  VkDevice, descriptorSet:  VkDescriptorSet, descriptorUpdateTemplate:  VkDescriptorUpdateTemplateKHR, pData: *const c_void, ) -> c_void;
	pub fn vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer:  VkCommandBuffer, descriptorUpdateTemplate:  VkDescriptorUpdateTemplateKHR, layout:  VkPipelineLayout, set:  u32, pData: *const c_void, ) -> c_void;
	pub fn vkSetHdrMetadataEXT(device:  VkDevice, swapchainCount:  u32, pSwapchains: *const VkSwapchainKHR, pMetadata: *const VkHdrMetadataEXT, ) -> c_void;
	pub fn vkGetRefreshCycleDurationGOOGLE(device:  VkDevice, swapchain:  VkSwapchainKHR, pDisplayTimingProperties: *mut VkRefreshCycleDurationGOOGLE, ) -> VkResult;
	pub fn vkGetPastPresentationTimingGOOGLE(device:  VkDevice, swapchain:  VkSwapchainKHR, pPresentationTimingCount: *mut u32, pPresentationTimings: *mut VkPastPresentationTimingGOOGLE, ) -> VkResult;
	pub fn vkCreateIOSSurfaceMVK(instance:  VkInstance, pCreateInfo: *const VkIOSSurfaceCreateInfoMVK, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkCreateMacOSSurfaceMVK(instance:  VkInstance, pCreateInfo: *const VkMacOSSurfaceCreateInfoMVK, pAllocator: *const VkAllocationCallbacks, pSurface: *mut VkSurfaceKHR, ) -> VkResult;
	pub fn vkCmdSetViewportWScalingNV(commandBuffer:  VkCommandBuffer, firstViewport:  u32, viewportCount:  u32, pViewportWScalings: *const VkViewportWScalingNV, ) -> c_void;
	pub fn vkCmdSetDiscardRectangleEXT(commandBuffer:  VkCommandBuffer, firstDiscardRectangle:  u32, discardRectangleCount:  u32, pDiscardRectangles: *const VkRect2D, ) -> c_void;
}
}
